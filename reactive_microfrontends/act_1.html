<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="Description"
    content="реактивность в мире веб разработки, реактивные системы, декомпозиция кода, поток управления, поток данных">
  <title>Реактивные Микро-фронтенды - Часть 1 (Экспозиция)</title>
  <link href="./style.css" rel="stylesheet">
</head>

<body>
  </link>

  <div data-item="container">
    <p data-item="text">
      Всем привет. Меня зовут Вадим. Я работаю lead разработчиком в компании EPAM. Мне нравится иногда делать доклады с
      использованием Svelte и размышлять на темы из области what if …?. Собственно, то, что вы сейчас
      читаете&nbsp;&ndash;&nbsp;это
      результат объединения двух моих увлечений.
    </p>

    <p data-item="text">
      Почему стоит потратить время на прочтение?
      Конечно, в первую очередь&nbsp;&ndash;&nbsp;это то, что тема на слуху, стоит только бросить взгляд на гугл-трендс
      чтобы увидеть
      растущую популярность. А если посмотреть программу ближайшего HolyJs, то можно также несколько раз заметить
      знакомое
      слово.
    </p>
    <br />

    <img alt="google trends" src="./assets/trends.png" />

    <span data-item="caption">
      «Microfrontend» trends
    </span>

    <br />

    <ul>
      <li>1. Следующий аргумент, нет ничего лучше, чем смотреть как кто-то набивает шишки. Эту информацию можно
        использовать в своей работе.</li>
      <li>2. <span data-item="highlight">Svelte</span> теперь официально поддерживает <span
          data-item="highlight">typescript</span>&nbsp;&ndash;&nbsp;мне кажется, самое больное место, которое тормозило
        использование фреймворка.</li>
      <li>3. <span data-item="highlight">Реактивность</span>, <span data-item="highlight">Микро-фронтенды</span>,
        “фреймворк только для виджетов”, на интуитивном уровне это все
        близко-близко друг к другу.</li>
      <li>4. В рунете достаточно материала по микро-фронтендам, но большинство, из которых я встречал либо описывают
        негативный опыт, либо описывают видение, которое отлично от моего. В этом докладе я бы хотел задать другое
        направление, через которое мы по-другому посмотрим на микро-фронтенды. Здесь нужно сделать оговорку, что <span
          data-item="highlight"></span>Svelte</span>
        как базовый инструмент выбран не совсем случайно, но он может быть заменен другим. Впрочем, обо все этом
        подробнее
        я расскажу дальше.</li>
      <li>5. И последнее, кроме всего прочего, я дитя поколения <span data-item="highlight">миллениалов</span> и получаю
        такое же удовольствие от просмотра
        фильмов, как и от чтения художественной литературы. Поэтому сегодня предлагаю вам окунуться в мою историю. Я,
        конечно, не Нолан, но постарался следовать классическим канонам трехактной структуры. Поехали.</li>
    </ul>

    <br />

    <h1> Акт I. Экспозиция</h1>
    <p data-item="text">
      Как водится, в любой классической истории необходимо присутствие протагониста. Таким протагонистом в этом докладе
      буду я сам. Но чтобы не ломать четвертую стену я буду называть себя “героем этого доклада” или просто “наш герой”.
    </p>

    <p data-item="text">
      Так вот, наш герой и его работа ничем не отличается от обычной рутины программиста. Просыпается к дэйли, работает
      и
      отдыхает за компьютером, сидит до поздней ночи. Но как я уже сказал, однажды этот привычный лад заканчивается и
      зерно сомнения дает всходы. Наш герой узнает, что за холмами, люди помимо реакта, используют другие фреймворки, а
      иногда и вовсе не нуждаются в них. Но самое удивительное, что редакс&nbsp;&ndash;&nbsp;это не единственный
      менеджер
      состояния. Наш
      герой загуглил mobx и оказывается он справляется со своей задачей на том же уровне, а иногда и лучше! Но вот, что
      странно&nbsp;&ndash;&nbsp;по всей документации красной нитью плетется слово <span
        data-item="highlight">реактивность.</span>
    </p>

    <br />

    <h2> Реактивность.</h2>

    <p data-item="text">
      Наверно, самый простой способ объяснить, что такое реактивность не используя термины из
      программирования&nbsp;&ndash;&nbsp;это
      сравнить ее с эффектом бабочки. Взмах крыла бабочки в Европе приводит к торнадо в Америке. Между двумя этими
      событиями может быть сколь угодно промежуточных событий, но они есть и мы знаем, что торнадо&nbsp;&ndash;&nbsp;это
      следствие взмаха
      крыла. Это как натянутое полотно пожарников, и все кто его держит точно почувствуют когда на него упадет человек.
      Но
      вернёмся к жизненным примерам.
    </p>

    <p data-item="text">
      Самый частый пример, который можно увидеть в любой статье про реактивность&nbsp;&ndash;&nbsp;это работа в excel.
    </p>

    <p data-item="text">
      Допустим у нас есть выражение типа <span data-item="highlight" style="white-space: nowrap">A = B + C</span>. Если
      у
      нас императивный подход, то
      в <span data-item="highlight">А</span> попадет результат сложения <span data-item="highlight">В и С</span>,
      использующих значения на момент выполнения этой операции. Переменные <span data-item="highlight">В и С</span>
      могут
      быть сто раз перезаписаны с новыми значениями, но это никак не повлияет на значение <span
        data-item="highlight">А</span>.
    </p>

    <br />

    <img alt="imperative approach" src="./assets/imperative.png" />

    <span data-item="caption">
      Императивный подход
    </span>

    <br />

    <p data-item="text">
      А теперь представим, что мы пишем код в <span data-item="highlight">excel</span>. И у нас есть выражение типа
      <span data-item="highlight" style="white-space: nowrap">А1 = B1 + C1</span>. Два столбца и сумма двух ячеек в
      ячейке
      третьего. Теперь же, в любой из
      моментов, когда мы будем менять значения ячеек <span data-item="highlight">В1</span> или <span
        data-item="highlight">С1</span>, значение ячейки <span data-item="highlight">А1</span> будет изменятся тоже.
      Этот
      процесс получил название&nbsp;&ndash;&nbsp;распространение изменений. А механизм, через который удается
      реализовать
      данный процесс,
      называют стримом, или потоком данных. Собственно отсюда и вытекают две главных составляющих реактивного
      программирования&nbsp;&ndash;&nbsp;<span data-item="highlight">реактивные ячейки и потоки данных</span>.
    </p>

    <br />

    <img alt="how it goes in excel" src="./assets/excel.png" />

    <span data-item="caption">
      Реактивный подход
    </span>

    <br />

    <h2> Принципы реактивности</h2>

    <p data-item="text">
      Далее, если мы обратимся к принципам реактивного программирования, описанным в книге <span
        data-item="highlight"><a rel="noopener" ` or `rel="noreferrer" target="_blank"
          href="https://livebook.manning.com/book/functional-reactive-programming/chapter-1/1">“Реактивное
          программирование в действии”</a></span>, мы увидим:
    </p>

    <ul>
      <li>1. Реактивность&nbsp;&ndash;&nbsp;это реакция на изменение данных;</li>
      <li>2. Система, написанная в реактивном стиле, является событийно-ориентированной (event-based);</li>
      <li>3. Программа, написанная в реактивном стиле должна рассматриваться как поток данных (flow of data), а не как
        классический поток управления (flow of control)</li>
    </ul>

    <p data-item="text">
      Все это позволяет нам ослабить связь между компонентами нашей программы, системы или приложения и писать модульный
      код.
      Это в прямом смысле означает, что классический подход к написанию кода больше не работает, нам более не важен
      порядок в каком будут написаны и вызваны наши инструкции. На первый взгляд выглядит как нелепица, но дайте мне
      объяснить все на примере.
    </p>

    <p data-item="text">
      Допустим нам нужно приготовить омлет, у нас есть рецепт и список покупок. Если бы мы следовали императивному
      подходу, то нам следовало бы хорошенько продумать последовательность наших действий, сходить в пятерочку за углом,
      купить молоко, купить яйца, включить плиту, выставить температуру, разбить яйца в миску, перемешать, добавить
      молоко
      и так далее. Все будет прекрасно работать, но если у нас появяться новые условия или новые действия, например, мы
      хотим пригласить гостей, и знаем что, у кого-то непереносимость лактозы. То нам необходимо будет проделать
      некоторую
      дополнительную работу (добавить или удалить шаги), чтобы исходная инструкция осталась рабочей.
    </p>

    <p data-item="text">
      Мы не справимся с задачей, весело провести завтрак, если мы будем использовать обычное молоко, а сами приглашаем
      гостей, которым необходимо безлактозное. Получается такая зависимость от инструкций, которые еще не случились.
    </p>

    <br />

    <img alt="imperative eggs" src="./assets/imperative-eggs.png" />

    <span data-item="caption">
      Готовим омлет по императивному
    </span>

    <br />

    <p data-item="text">
      Но если мы развернем зависимость в обратную сторону, то мы сможем ослабить связь между инструкциями и
      переиспользовать их как независимые модули.
    </p>

    <p data-item="text">
      Что я имею в виду. Вместо того чтобы покупать молоко для специальных гостей, мы приглашаем гостей, основываясь на
      купленном молоке. Таким образом наш исходный алгоритм не разбивается на более мелкие шаги, а наоборот собирается
      из
      таких мелких модулей.
    </p>

    <p data-item="text">
      Еще проще. У нас есть два независимых модуля, которые выполняют функцию приглашения гостей. Один зовет гостей с
      переносимостью лактозы, другой без, возможно там что-то еще, не суть сейчас. Оба они подписаны на событие о том
      какое молоко куплено. И как только такое событие происходит, срабатывает соответствующий модуль. Эти модули ничего
      не знают про общую цель, они лишь выполняют свою функцию в рамках событий, на которые подписаны.
    </p>

    <br />

    <img alt="reactive eggs" src="./assets/reactive-eggs.png" />

    <span data-item="caption">
      Готовим омлет по реактивному
    </span>

    <br />

    <h2> Бенефиты реактивности </h2>

    <p data-item="text">
      Какие бенефиты это несет:
    </p>

    <ul>
      <li>1. Во-первых, как уже много раз было сказано&nbsp;&ndash;&nbsp;модульность и независимость друг от друга, что
        повышает
        переиспользуемость данных модулей.</li>
      <li>2. Декларативность, мы больше не говорим “как” сделать, мы говорим “что”. Упаковываем инструкции в модуль и
        называем
        привычным нам языком.</li>
    </ul>

    <br />

    <p data-item="text">
      Предвкушаю ваш следующий вопрос...
    </p>

    <img alt="the fuck is it" src="./assets/thefuck.png" />

    <br />

    <p data-item="text">
      Поэтому пришло время срывать маски. Все это время под маской реактивного программирования был обычный <span
        data-item="highlight">observer pattern</span>. Даже если вы не поверили мне и пойдете сами изобретать реактивное
      программирование на javascript, вы скорее всего изобретаете observer pattern.
    </p>

    <p data-item="text">
      Даже если это будет не классический observer pattern, это все равно будет некоторым подобием
      событийно-ориентированной архитектуры, о чем мы поговорим чуть далее.
    </p>

    <img alt="mask off" src="./assets/maskoff.png" />

    <br />

    <p data-item="text">
      Здесь следует провести черту и рассказать в чем между ними отличия, хотя оба термина (событийно-ориентированная
      архитектура и observer pattern) все еще находятся в поле реактивного программирования и оба удовлетворяют принципу
      распространения изменения.
    </p>

    <p data-item="text">
      <span data-item="highlight">Event-driven architecture</span>&nbsp;&ndash;&nbsp;такой шаблон организации
      независимых
      модулей, при
      котором механизму, который генерирует события в общем-то все равно, кто эти события будет слушать. Это как <span
        data-item="highlight">broadcast</span>, событие попадает в какой-то общий канал и все его участники это событие
      могут обработать, асинхронно. Зачастую такие события практически обезличены и не несут какой-либо специфичной
      информации, возможно только метаданные самого события.
    </p>

    <p data-item="text">
      Отличным примером такого подхода могут служить <span data-item="highlight">DOM события</span>. По большому счету
      браузеру все равно, какой фреймворк сейчас обрабатывает события, а тем более кто там подписался на клик на бади.
    </p>

    <img alt="events" src="./assets/events.png" />

    <br />
    <br />

    <p data-item="text">
      Второй подход заключается в использовании observer pattern. Ключевое отличие от EDA состоит в том, что элемент,
      который генерирует событие, заставляет всех своих подписчиков обработать это событие в синхронном режиме.
    </p>

    <p data-item="text">
      Жонглируя этими подходами, расширяя и сужая возможности, можно реализовать действительно хороший инструмент
      распространения изменений в вашем javascript приложении. Я оставлю несколько ссылок на статьи где описываются
      хорошие реактивные системы в существующих инструментах и фреймворках, таких как <a rel="noopener" ` or
        `rel="noreferrer" target="_blank"
        href="https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969/#:~:text=Svelte%203.0%20moves%20reactivity%20out,API%20and%20into%20the%20language.&text=setState%20in%20React%20%28and%20most,completely%20unaware%20of%20data%20changes.">Svelte</a>,
      <a rel="noopener" ` or `rel="noreferrer" target="_blank"
        href="https://antfu.me/posts/watch-with-reactivity/">Vue</a>, <a rel="noopener" ` or `rel="noreferrer"
        target="_blank" href="https://www.pzuraq.com/what-makes-a-good-reactive-system/">Ember, RxJs, Elm</a>.
    </p>

    <span class="divider">.................</span>

    <p data-item="text">
      Итак, разобрались. Реактивность&nbsp;&ndash;&nbsp;неплохой взгляд на то, как можно писать код. Но нет ли у вас
      ощущения, что все
      равно, что-то не так?
    </p>

    <p data-item="text">
      Потому что, если все хорошо, мы бы взяли наш отлаженный рабочий реактивный фреймворк и работали бы в свое
      удовольствие. Но нет, мы каждое утро заходим в твиттер и видим как кто-то постит, что нашел сильно пахнущий кусок
      кода в своем проекте. Читаем новые книжки про архитектуру. Собираемся на конференциях и пытаемся научится чему-то.
      Зачем, если есть такая вещь как реактивность? Зачем нам что-то другое?
    </p>

    <p data-item="text">
      Что же, в каждой статье на медиуме присутствует раздел про минусы, такой раздел есть и у реактивности. Это
      управление сложностью. Как только ваш проект разрастается, зачастую, если разработчики пропустили этот момент, вся
      реактивщина превращается в тыкву. Поскольку реактивные системы&nbsp;&ndash;&nbsp;это, по большей части, модульные
      системы, связность
      таких модулей становится очень тесной. Весь проект начинает выглядеть как таиландские провода. Становится
      непонятно,
      откуда и куда идут сообщения, что триггерит что. Продолжать разработку, тестирование и прочие активности
      становится
      ужасно больно.
    </p>

    <br />

    <img alt="thai wires" src="./assets/wires.png" />

    <br />
    <br />

    <p data-item="text">
      Дойдя до этого этапа, наш герой, казалось, разочаровался в жизни. Зачем давать такую сладкую надежду, чтобы тут же
      облить ее керосином и поджечь, мир не может быть настолько жестоким. Но первый акт подходит к концу, поэтому на
      горизонте маячит переломный момент. Наш герой находит “рояль в кустах”. Книга! Заповеди программирования (не
      является настоящей книгой)! Наш герой судорожно листает страницы и повторяет,&nbsp;&ndash;&nbsp;“ответы, мне нужны
      ответы!”, глаза
      останавливаются на строчке, герой читает&nbsp;&ndash;&nbsp;“Пишите код так, как будто сопровождать его будет
      склонный к насилию
      психопат, который … ”,&nbsp;&ndash;&nbsp;“Это все не то!”,&nbsp;&ndash;&nbsp;кричит герой. И дойдя до последней
      страницы, наш герой замечает, как
      кто-то карандашом, еле-еле видно, нарисовал на обложке несколько символов. Он приглядывается и видит странную
      надпись.
    </p>

    <p data-item="text">
      💩💩💩&nbsp;лучше чем&nbsp;<span style="font-size:85px">💩</span>
    </p>

    <p data-item="text">
      На лице у него сияет улыбка и он отправляется в свое новое путешествие, из которого он уже не сможет вернуться
      прежним.
    </p>

    <p data-item="text">
      <a href="https://vtcaregorodtcev.github.io/blog/reactive_microfrontends/act_2">Продолжить чтение</a>
    </p>
  </div>
</body>

</html>
