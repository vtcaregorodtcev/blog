<link href="./style.css" rel="stylesheet">
</link>

<div data-item="container">

  <img class="intro-img" src="./assets/witcher.png" />

  <br />

  <h1> Акт II. Из двух зол ...</h1>

  <p data-item="text">
    Итак, с маленькой кодовой базой намного легче работать чем с большой. Надеюсь, всем удалось разгадать мой ребус в
    прошлом акте.
  </p>

  <p data-item="text">
    А что в свою очередь выглядит как множество независимых модулей? Правильно, микро-фронтенды. Давайте о них и
    поговорим.
  </p>

  <p data-item="text">
    Небольшое отступление. Все о чем я далее буду рассказывать базируется в основном на двух священных писаниях по
    микро-фронтендам. Это книга <a target="_blank"
      href="https://livebook.manning.com/book/micro-frontends-in-action/chapter-1/v-4/1">“микро-фронтенды в
      действии”</a> от Майкла Гирса и <a target="_blank"
      href="https://martinfowler.com/articles/micro-frontends.html">лонгрид на martinfowler</a>. Поэтому, если после
    доклада появится желание побольше преисполниться в этой теме, то вы будете знать где искать.
  </p>

  <br />

  <h2> Фантастические микро-фронтенды и места их обитания.</h2>

  <p data-item="text">
    Итак, что мы знаем про микро-фронтенды? “Чтобы понять, что такое микро-фронтенды, надо думать как микро-фронтенды” -
    скажете вы. А что, если я скажу вам, что вы уже работали с микро-фронтендами. Ведь <span
      data-item="highlight">микро-фронтенды&nbsp;&ndash;&nbsp;это НЕ новая технология</span>, это альтернативный способ
    организовать
    вашу повседневную работу. Микро-фронтенды&nbsp;&ndash;&nbsp;это то, что у вас получается, когда вы находитесь в
    промежуточном этапе
    миграции одного фреймворка на другой, одной версии на другую, когда вы переводите свое javascript приложение на
    typescript.
  </p>

  <p data-item="text">
    В этом высказывании есть зерно правды, но все-таки оно остается не очень точным, поэтому я предлагаю вам представить
    микро-фронтенды в виде пиццы. Да, после моего монолога захочется покушать. Кусочек за кусочком мы будем
    отрывать новую информацию, пока не утолим наш голод познания.
  </p>

  <p data-item="text">
    Поэтому давайте оторвем первый кусок и узнаем что в принципе нам могут предложить микро-фронтенды и какие проблемы
    они решают.
  </p>

  <br />

  <h2> Show me whatchugot!</h2>

  <p data-item="text">
    Самое главное изменение, которое предлагают микро-фронтенды&nbsp;&ndash;&nbsp;это отказ от горизонтального
    планирования команд в
    пользу <span data-item="highlight">вертикального</span>. Что это значит?&nbsp;&ndash;&nbsp;Спорю, что здесь у многих
    уже есть опыт
    работы в подобных командах. Это так называемые <span data-item="highlight">кросс-функциональные команды</span>,
    когда команды состоят из специалистов, которые единолично могут выводить новые фичи в продакшен, начиная от
    планирования идеи и дизайна, заканчивая полированием производительности sql запросов.
  </p>

  <br />

  <img src="./assets/vertical.png" />

  <span data-item="caption">
    Горизонтальные команды заменяются вертикальными
  </span>

  <br />

  <p data-item="text">
    Здесь может возникнуть резонный вопрос, чем это вертикальное планирование лучше? Если фронтендеры работают бок о бок
    с фронтендерами, бэкендеры с бэкендерами, они могут помогать друг другу, обсуждать баги и делать наилучшее решение,
    которое только смогут сделать. И, если на каждом слое мы получим наилучшее решение, не сделает ли это только лучше
    для всего приложения? Это заявление не всегда так работает в жизни. Как показывает практика, если фронтендеры
    работают бок о бок с бэкендерами и с ребятами из бизнеса это позволяет увидеть проблему продукта с разных сторон и
    прийти к самому эффективному и креативному решению. Возможно, оно будет не самое лучшее с технической точки зрения,
    но зато оно будет соотноситься с миссией команды.
  </p>

  <br />

  <img src="./assets/orientation.png" />

  <br />

  <p data-item="text">
    Это позволяет всем членам команды принимать участие в его создании и фокусироваться на конкретном опыте
    пользователя, что невозможно при горизонтальном планировании. В этом случае очень трудно идентифицировать себя с
    продуктом, поскольку все требования приходят сверху и не требуют концентрации, чего не происходит при вертикальном
    планировании.
  </p>

  <br />

  <img src="./assets/required-vertical.png" />

  <span data-item="caption">
    Работа с требованиями при вертикальном планировании
  </span>

  <br />

  <img src="./assets/required-horizontal.png" />

  <span data-item="caption">
    Работа с требованиями при горизонтальном планировании
  </span>

  <br />

  <p data-item="text">
    На этом моменте мы уже можем увидеть следующие бенефиты использования микро-фронтендов:
  </p>
  <ul>
    <li> 1. Быстрая и независимая доставка новых фич в прод. Когда у тебя небольшая ангажированная кросс-функциональная
      команда, тебе намного легче принимать решения, поскольку в команде уже есть все необходимые компетенции. Тебе
      больше не нужно создавать митинг на 20 человек, чтобы обсудить название переменных.</li>
    <li>2. Фокус на проблеме пользователя. Команды разрабатывают фичи непосредственно для конечного потребителя. У
      команды появляется миссия.</li>
    <li>3. Использование технологий, которые делают счастливыми самих разработчиков, больше никаких “так исторически
      сложилось”. Кроме того, поскольку кодовая база микро-фронтенда настолько мала, ее бесконечно (в теории) можно
      переписывать, придавая ей более элегантный вид.</li>
    <li>4. Предсказуемое поведение микро-фронтендов, поскольку все фичи команды конкретны и упакованы в своеобразный
      контейнер. Поиск ошибок становится простым и сводится к небольшому участку кодовой базы.</li>
  </ul>

  <p data-item="text">
    Сейчас прямо чувствую, по ту сторону экрана как вы такие,&nbsp;&ndash;&nbsp;“wait a minute, то есть микро-фронтенды
    заставляют нас
    менять структуру команд, запрещают нам коммуницировать между командами, потому что это очень дорого по времени и
    клиенты не ждут, им нужны новые фичи. Но ничего нам не говорят про то, что теперь нам нужно писать ещё больше кода,
    так как в каждой команде и в каждом микро-фронтенде есть общие куски кода, общие компоненты, а горизонтально мы их
    не можем переиспользовать, потому что это опять трата времени. И вообще, что делать со стилями?”
  </p>

  <p data-item="text">
    Это очень правильный вопрос, и уверен, если вы решитесь связаться с микро-фронтендами, то будете задавать его очень
    часто.
  </p>

  <p data-item="text">
    Конечно же, здесь тоже нет серебрянной пули и отрывая следующий кусочек от нашей пиццы (переиспользование общих
    ресурсов), мы осознанно делаем эту концепцию, в каком-то роде, противоречивой.
  </p>

  <p data-item="text">
    Никто не считает создание общей библиотеки компонентов чем-то плохим, это всегда помогает увеличивать скорость
    разработки и не писать тонны повторяющихся компонентов. Но всегда существует очень много моментов из-за которых все
    может пойти не так. Обычно, это создание такой библиотеки с большим количеством компонентов на очень раннем этапе.
    Поскольку апи для таких компонентов будет сыро на протяжении некоторого времени, это будет приводить к тому, от чего
    нас пытаются уберечь микро-фронтенды&nbsp;&ndash;&nbsp;коммуникации среди команд и огромная трата времени, потому
    что когда люди
    разговаривают, они не работают.
  </p>

  <p data-item="text">
    К той же трате времени можно отнести вопрос&nbsp;&ndash;&nbsp;“Кто будет следить за такой библиотекой?”. Очень часто
    можно получить
    ответ, что все команды будут и должны мониторить изменения, но если переводить с разработческого языка, то это
    значит никому это не будет нужно. А выделять дополнительную команду или человека&nbsp;&ndash;&nbsp;это серьезное
    решение.
  </p>

  <p data-item="text">
    Также, очень часто бывает, что в такие расшаренные библиотеки попадают компоненты, которые явно завязаны на какую-то
    часть бизнес логики, какая-нибудь user-table. Но это неправильно, даже если мы не используем микро-фронтенды.
    Поэтому, единственными кандидатами на выселение в расшаренные библиотеки становятся такие примитивные вещи как
    иконки, инпуты и кнопки. И уже решение о выделении доп команды для такой библиотеки становится еще абсурдней.
  </p>

  <p data-item="text">
    “Но, а как же стилизация, кастомизация и вот это вот все?”&nbsp;&ndash;&nbsp;спросите вы, а я в ответ покажу
    отличный <a target="_blank" href="https://youtu.be/A3CamtT9VBs">доклад с прошлого холи</a> про быструю доставку
    дизайна в
    код.
  </p>

  <p data-item="text">
    Ребята рассказывают, как можно сделать <span data-item="highlight">из вашего дизайна переиспользуемый ресурс</span>.
    Когда все базовые примитивы, такие как цвета, размеры или отступы, лежат в одном месте (в фигме) и их очень легко
    применить на ваш боевой код. Таким образом, легко решается проблема коммуникаций, поскольку их просто не будет,
    дизайнеры будут разговаривать, а разработчикам остается только договориться о том, как этот дизайн будет применяться
    в их приложениях.
  </p>

  <p data-item="text">
    Все, что нужно сделать&nbsp;&ndash;&nbsp;это корректное использование css и валидный html. Семантические теги и
    соглашение по
    именованию классов, ну или нечто, что позволит изолировать классы для отдельных компонентов, благо таких
    инструментов
    огромное кол-во, от css модулей и css-in-js до shadow-dom.
  </p>

  <p data-item="text">
    Вижу ваше немое возмущение,&nbsp;&ndash;&nbsp;“Эммм, я не хочу писать 23 раза ...."
  </p>

  <img src="./assets/23times.png" />

  <br />

  <p data-item="text">
    я хочу писать
  </p>

  <img src="./assets/1time.png" />

  <br />

  <p data-item="text">
    Поэтому, мы возвращаемся в начало и именно поэтому мы до конца не можем снять противоречие в переиспользовании общих
    ресурсов.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Ладно, давайте пока это оставим и перейдем к самому интересному, что есть в микро-фронтендах. То, как их нужно
    собирать вместе и как они должны при этом общаться.
  </p>

  <h2> Micro Frontends assemble!</h2>

  <img src="./assets/assemble.png" />

  <br />

  <h3> Build-time solutions</h3>

  <p data-item="text">
    Итак, поразмыслив над концептами, которые предлагают нам микро-фронтенды, давайте перейдем непосредственно к самим
    микро-фронтендам.
  </p>

  <p data-item="text">
    И, рассказывая про первый способ организации микро-фронтендов, я бы представил, как пользователь заказывает пиццу у
    официанта. Он говорит <span data-item="highlight">/пицца</span> и официант дает слайс пепперони, пользователь
    говорит <span data-item="highlight">/бургер</span> и официант дает бургер. Как вы догадались этим официантом может
    быть <span data-item="highlight">nginx</span> или любой другой инструмент, который поможет загружать отдельные
    микро-фронтенды полагаясь на <span data-item="highlight">location и path</span> который получает.
  </p>

  <p data-item="text">
    На мой взгляд, сейчас&nbsp;&ndash;&nbsp;это самый популярный способ разбить большое приложение на отдельные модули и
    раздать их
    отдельным командам. Но, единственное, что здесь не так&nbsp;&ndash;&nbsp;это перезагрузка страницы каждый раз при
    смене урла.
  </p>

  <img src="./assets/nginx.png" />

  <br />

  <p data-item="text">
    Небольшое улучшение в этот способ может привнести <span data-item="highlight">ssi</span>, или серверные вставки.
    Немного изменив конфигурацию мы сможем переиспользовать элементы, которые не требуют частых изменений, футеры,
    хедеры и вот это вот все.
  </p>

  <img src="./assets/nginx2.png" />
  <span class="divider">.................</span>
  <img src="./assets/nginx3.png" />

  <br />

  <p data-item="text">
    Ведь что такое веб-приложение? В первую очередь это верстка, некоторый кусочек html разметки. А микро-фронтенды -
    это другие кусочки, которые мы вставляем в нужном порядке в наш исходный кусок. Если мы вернемся к использованию
    первого варианта, с загрузкой полного приложения на новый урл, это снова откинет нас к нашей проблеме, обсуждения
    того, что должно быть одинаковым в разных приложениях. Поэтому, если уж мы и говорим про микро-фронтенды, то имеет
    смысл всегда иметь некоторый контейнер, который мы наполняем нашими модулями и всем, что в них одинаково.
  </p>

  <p data-item="text">
    Этот контейнер принято называть <span data-item="highlight">host-приложением</span>, для него выделяется отдельная
    команда, и обычно это приложение решает больше инфраструктурные вещи, роутинг, аутентификацию и прочее. Поэтому
    далее в примерах мы будем иметь в виду, что наши микро-фронтенды собираются как раз таки в такой host.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Идем дальше. И следующий способ организации микро-фронтендов, наверное, мог бы возникнуть если бы мы спросили об
    этом
    фронтенд разработчика образца 2015 года.
  </p>

  <p data-item="text">
    Поскольку вся кодовая база отдельного микро-фронтенда должна быть изолирована от других частей и нам достаточно
    только знать точку, в которую мы собираемся монтировать наш микро-фронтенд, то почему бы не завернуть весь модуль в
    отдельный пакет и собирать все приложение как-будто из отдельных компонентов.
  </p>

  <img src="./assets/thisisnpm.png" />

  <br />

  <p data-item="text">
    В таком случае мы получаем настоящую изоляцию, разработка все еще остается параллельной, и мы можем с легкостью
    переиспользовать зависимости, которые могут быть у нескольких микро-фронтендов.
  </p>

  <p data-item="text">
    На мой взгляд, это и смутило Дена Абрамова в микро-фронтендах и сподвигло его на <a target="_blank"
      href="https://twitter.com/dan_abramov/status/1132493678730252288">данный твит</a>.
  </p>

  <p data-item="text">
    Очевидно же, зачем нам отдельные приложения в отдельных пакетах, когда можно хорошо продумать компонентную
    составляющую всего приложения, вынести общие части и радоваться? Но только микро-фронтенды&nbsp;&ndash;&nbsp;это не
    только про то
    как их вместе организовать, это еще про <span data-item="highlight">скорость и фокус</span>.
  </p>

  <p data-item="text">
    Никакого смысла в пакетах нет, так как это все равно блочит команду от быстрых релизов, поскольку на каждый апдейт
    версии отдельного пакета, нужно обновлять host приложение, а это опять потеря времени.
  </p>

  <p data-item="text">
    Кроме того, компоненты вынесенные в отдельные пакеты, никакой бизнес задачи не решают&nbsp;&ndash;&nbsp;это все
    инфраструктурные
    вещи, которые облегчают жизнь разработчикам. Но, если же мы говорим про микро-фронтенды, то это прямо-таки
    конкретный
    инструмент бизнеса, мы держим фокус на конкретной проблеме и моментально реагируем на малейшие изменения. Поэтому
    данный подход не совсем подходит к тому, о чем мы пытаемся рассуждать здесь.
  </p>

  <br />

  <h3> Run-time solutions</h3>

  <p data-item="text">
    Итак, предыдущие способы организации были направлены, в основном, на работу на сервере либо во время сборки
    (build-time integration) всего приложения. Пришло время обсудить решения для run-time.
  </p>

  <p data-item="text">
    Первым и самым популярным кандидатом, наверное, становится <span data-item="highlight">iframes</span>.
  </p>

  <p data-item="text">
    Слышу шепот по ту сторону экрана,&nbsp;&ndash;&nbsp;“Он что, сказал iframes?”. Да. Если мы вспомним, о чем говорили
    в начале второго
    акта, про то, что нам предлагают микро-фронтенды, (изоляция, быстрая разработка и тд) то iframes спокойно
    вписываются в эту концепцию. Но почему же в веб-разработке принято не любить iframes?
  </p>

  <p data-item="text">
    Что же, тут есть несколько причин, из-за которых придется поломать голову.
  </p>
  <ul>
    <li>1. Когда мы говорим про изоляцию, то имеем в виду прям изоляцию-изоляцию, что делает этот подход менее гибким.
    </li>
    <li>2. Существуют также особенности в коммуникации между host приложением и iframes, можно же, конечно, использовать
      postMessage protocol, но поскольку iframes&nbsp;&ndash;&nbsp;это буквально браузер в браузере, это накладывает
      определенные
      трудности,
      особенно, когда таких браузеров несколько на странице.</li>
    <li>3. Контролировать состояние url iframes тоже проблематично, поскольку оно никак не будет представлено в url
      самой страницы. И у нас просто так не получится делиться ссылками и надеяться, что мы будем получать ту же самую
      страницу
      каждый раз.</li>
  </ul>

  <p data-item="text">
    Эти проблемы, конечно, не самые сложные, но заставляют лишний раз подумать, нужно ли их решать. (life is too short
    to use iframes).
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Следующий способ, который я бы хотел осветить, предельно похож на предыдущий. Вместо iframes можно использовать
    <span data-item="highlight">web-components</span>, они же кастомные элементы. Каждый ваш микро-фронтенд прячется под
    кастомным тегом. Его можно разместить в любом месте вашего приложения, а чтобы кастомный тег работал, достаточно
    просто подключить скрипт с его определением, что можно сделать в ленивом стиле.
  </p>

  <img src="./assets/web-components.png" />

  <br />

  <p data-item="text">
    Я уже упоминал, что микро-фронтенды&nbsp;&ndash;&nbsp;это то, что получается у нас в моменте миграции и
    веб-компоненты, как
    промежуточное звено, очень хорошо себя здесь чувствуют. Для более подробной информации можно ознакомиться с <a
      target="_blank" href="https://youtu.be/CaP5eAylYpI">докладом Дениса Мишунова</a> или с <a target="_blank"
      href="https://youtu.be/FBk5j62O4f0">одним из моих</a> предыдущих докладов, где я показывал как можно мигрировать с
    реакта на свелт.
  </p>

  <img src="./assets/migration.png" />

  <br />

  <p data-item="text">
    Если мы используем веб-компоненты, то мы сразу избавляемся от проблем роутинга и коммуникации. Поскольку
    веб-компоненты это просто js файл, мы его подключаем как отдельный скрипт на страницу, что нисколько не блочит
    релизный цикл каждого отдельного микро-фронтенда, достаточно просто загружать каждый раз последнюю версию этого
    самого веб-компонента. И host приложение будет up to date. Также, как только веб-компонент загрузится он станет
    частью страницы, которую мы просматриваем. Все данные, которые доступны этой странице, с легкостью можно передать
    веб-компоненту в обычном стиле через атрибуты тега. Таким образом, мы никогда не потеряем состояние, если захотим
    расшарить ссылку.
  </p>

  <p data-item="text">
    Но всегда есть но. АПИ для веб-компонентов все еще вызывает вопросы, и множество проблем, которые уже решены при
    помощи других инструментов, все еще присущи веб-компонентам. Поэтому однозначного ответа в отношении этой технологии
    еще нет, право выбора все еще лежит на плечах разработчика.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Последний способ, который я хотел бы рассмотреть&nbsp;&ndash;&nbsp;это композиция микро-фронтендов в рантайме при
    помощи обычного
    js. Этот способ предельно похож на предыдущий, но только нам не нужно инкапсулировать всю логику внутри
    веб-компонента и использовать дополнительные технологии, чтобы не плодить баги.
  </p>

  <p data-item="text">
    Опять же, в основе лежит тот факт, что любое веб-приложение это всего лишь верстка, кусок верстки, и чтобы
    использовать микро-фронтенды нам нужно загрузить ещё один кусок верстки. С этим прекрасно справляются современные
    фреймворки. Все, что нам нужно сбилдить&nbsp;&ndash;&nbsp;наше приложение на реакте, ангуляре, вью в два файлика js,
    css и все. Заранее
    на странице мы расставляем теги со специальными айдишниками, и добавляем тег скрипт с ссылкой на наш js. После того,
    как скрипт загрузится, фреймворк найдет свой айдишник и инициализирует микро-фронтенд.
  </p>

  <img src="./assets/bundle.png" />

  <span class="divider">.................</span>

  <img src="./assets/bundle2.png" />

  <br />

  <p data-item="text">
    Среди перечисленных выше способов композиции микро-фронтендов нет однозначно плохих, но, вероятно, последний
    наиболее удобный в работе с ними. Поскольку мы работаем с нативным js, мы сами вольны вносить или не вносить
    сложности и абстракции. Мы сохраняем способность быстро и независимо деплоить новые изменения не затрагивая хост. А
    поскольку мы все еще остаемся в едином контексте, чего нет в iframes или web-components, мы облегчаем себе работы по
    коммуникации среди всех микро-фронтендов.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Итак, что мы уже узнали к этому моменту?
  </p>

  <ul>
    <li>1. Что микро-фронтенды это не про технологии, это про организацию работы.</li>
    <li>2. Микро-фронтенды нацелены на быструю разработку и бесконечное улучшение текущей кодовой базы каждого
      отдельного
      микро-фронтенда.</li>
    <li>3. Самый гибкий способ работы с микро-фронтендами&nbsp;&ndash;&nbsp;это использовать обычный js, для загрузки
      модулей в рантайме
      и
      монтирования их в хост приложение.</li>
  </ul>

  <br />

  <p data-item="text">
    Единственное чеховское ружьё, которое еще не выстрелило&nbsp;&ndash;&nbsp;это реактивность, с которой мы
    познакомились в первом
    акте, и единственная тема которую нам надо рассмотреть&nbsp;&ndash;&nbsp;это коммуникации среди микро-фронтендов.
    Давайте убьем двух
    зайцев одним выстрелом.
  </p>

  <br />

  <h2> Позови меня тихо по ивенту</h2>

  <p data-item="text">
    Есть такая пословица (или нет): “Прежде чем что-то сказать, лучше трижды подумать”. Это относится и к коммуникациям
    микро-фронтендов. Почему так?
  </p>

  <p data-item="text">
    Как ни странно, коммуникации&nbsp;&ndash;&nbsp;это тоже переиспользуемый ресурс, а значит что? Правильно, мы блочим
    сами себя, вводя
    любые способы общения. Чем больше каналов, тем больше мест, где что-то пойдет не так и придется совместно решать,
    как это исправить. Поэтому, по возможности, стоит избегать любого общения между микро-фронтендами.
  </p>

  <p data-item="text">
    Если же происходит иначе, от спринта к спринту вы замечаете, что общение между двумя микро-фронтендами только
    увеличивается, то значит пришло время пересмотреть границы ответственности двух команд, отвечающих за эти
    микро-фронтенды.
  </p>

  <img src="./assets/communication.png" />

  <br />

  <p data-item="text">
    Далее, если мы все-таки допускаем, что наши микро-фронтенды каким-то образом коммуницируют, то что они должны
    пересылать друг-другу? На мой взгляд&nbsp;&ndash;&nbsp;это должны быть только нотификации или события о чем-то. Как
    если бы это были
    обычные события DOM.
  </p>

  <p data-item="text">
    Это создает образ более естественной коммуникации. Большой payload события вызывает вопросы:
  </p>
  <ul>
    <li>
      1. Как это типизировать и держать в актуальном состоянии?</li>
    <li>2. Почему тогда не использовать бэкенд для этих целей, если такой большой кусок данных, должен быть расшарен
      между
      разными областями ответственности? Но здесь наверно нужно послушать доклады Андрея Мелихова про BFF, чтобы
      ориентироваться, что где должно быть.</li>
  </ul>

  <p data-item="text">
    Идем далее. Теперь нам нужно установить каким может быть общение в принципе. Мы можем коммуницировать в следующих
    направлениях:
  </p>

  <ul>
    <li>Хост -> микро-фронтенд (прямая вставка)</li>
    <li>Хост -> микро-фронтенд микро-фронтенда</li>
    <li>Микро-фронтенд -> Хост (обратная связь)</li>
    <li>Микро-фронтенд микро-фронтенда -> Хост</li>
    <li>Микро-фронтенд -> Микро-фронтенд (плоское взаимодействие)</li>
  </ul>

  <p data-item="text">
    А еще мы можем выбросить этот список и больше не вспоминать как страшный сон. Поскольку у нас изолированные
    микро-фронтенды, общение возможно построить только на событиях и все микро-фронтенды будут находиться в плоской
    структуре, поэтому актуальный способ организации взаимодействия <span data-item="highlight">микро-фронтенд ->
      микро-фронтенд</span>.
  </p>

  <img src="./assets/putit.png" />

  <br />
  <br />

  <h3> Custom Events</h3>

  <p data-item="text">
    Итак, первый кандидат на звание "инструмент коммуникации микро-фронтендов"&nbsp;&ndash;&nbsp;custom events. Довольно
    легко было
    догадаться.
  </p>

  <p data-item="text">
    Что могут нам предложить кастомные события. Очень много на самом деле. Как и обычные события они имеют название и
    некоторую метаинформацию, кроме всего прочего, мы сами можем наполнять payload или <span
      data-item="highlight">detail</span> таких событий.
  </p>

  <img src="./assets/custom-events.png" />

  <span class="divider">.................</span>

  <img src="./assets/custom-events2.png" />

  <br />

  <p data-item="text">
    По умолчанию, кастомные события не всплывают до window. Поэтому это может вызвать некоторые трудности. Всегда нужно
    будет использовать сам window как глобальную базу для всех событий. Зарегистрировать и вызвать ивент в одном
    микро-фронтенде, поймать в другом. Это будет работать, но мы можем включить всплытие и тогда в метаинформацию
    события также попадет таргет&nbsp;&ndash;&nbsp;элемент, на котором произошло событие, если, конечно, нужна некоторая
    дополнительная
    информация для дебага. Помимо прочего, такое событие можно будет остановить по пути наверх.
  </p>

  <p data-item="text">
    Поддерживаются кастомные события во всех браузерах, за исключением IE, хотя там тоже можно сделать хак.
  </p>

  <br />

  <h3> Broadcast Channel API</h3>

  <p data-item="text">
    Следующий кандидат, который доступен из коробки почти во всех браузерах, бродкаст ченел. Данное апи позволяет
    осуществлять базовую коммуникацию между окнами, табами, iframes и воркерами, указанным в названии способом.
  </p>

  <img src="./assets/broadcast.png" />

  <br />

  <p data-item="text">
    Что мы можем сделать? Создать канал с определенным именем. Подписаться на данный канал при помощи onmessage. Послать
    сообщение через postMessage в канал, и все, кто был подписан получат данное сообщение. Можно посылать
    сериализованные объекты, кроме DOMString. Хотя, это и облегчает работу с некоторым payload, наверное это может
    вызвать
    некоторые трудности с типизацией.
  </p>

  <img src="./assets/broadcast2.png" />

  <br />

  <p data-item="text">
    Стоит иметь в виду, поскольку мы говорим про события в рантайме фронтенда, как я уже упоминал, может быть такая
    ситуация, когда ваш микро-фронтенд еще не готов, чтобы слушать или отправлять события. Поэтому если считаете, что
    это ваш кейс, то, наверное, в качестве шины событий лучше использовать какой-нибудь общий сервис на бэкенде.
  </p>

  <p data-item="text">
    Заканчиваю мое последнее предложение и уже слышу как вы яростно бьете по экранам ваших телефонов, “Как так, какие
    события? А если мне надо шарить состояние? Ну надо!”. Тогда я обязан познакомить вас с докладом Паши Малышева, про
    <a target="_blank" href="https://youtu.be/kf5zccSyEso">“роутер как у сына маминой подруги”</a>. Ну, или если вы
    писали на Эмбер, то идея тоже должна быть вам знакома.
  </p>

  <p data-item="text">
    Идея в следующем: УРЛ строка браузера&nbsp;&ndash;&nbsp;самое лучшее место для хранения состояния приложения. Всегда
    единственный
    источник правды. Причем, мы можем замапить несколько микро-фронтендов на один урл, но внутри самих микро-фронтендов
    он будет обрабатываться по-разному. Все, что нам будет нужно&nbsp;&ndash;&nbsp;это настроить роутер в хост
    приложении, чтобы тот
    корректно обрабатывал события о смене урла. Например, пользователь кликает на товар, происходит событие выбора,
    роутер ловит это событие и плавно подменяет один микро-фронтенд на другой. И, в зависимости от того, изменились ли
    параметры в урле или нет, на странице могут происходить другие изменения (открытие модальных окон, изменения
    счетчиков и прочее). Реактивный интерфейс как он есть.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Итак, наш герой настолько преисполнился в своем познании, что теперь может использовать микро-фронтенды на работе.
    Наш герой пошел на работу и объявил там, что теперь все должны писать микро-фронтенды. На него странно посмотрели,
    но спорить не стали. В итоге вместо общего скоупа функциональных групп, наш герой собрал три кросс-функциональные
    команды. Первые две выбрали в качестве своего инструмента реакт, кто бы сомневался. Третья команда остановилась на
    вью и решила что будет писать хост приложение.
  </p>

  <p data-item="text">
    Реакт команды сразу смекнули, у нас у обоих в зависимостях реакт и реакт-дом, будет не комильфо два раза загружать
    по 130 кб. Давай это дело переиспользуем. Команды настроили сборку общих зависимостей в пакет, договорились с
    командой вью, чтобы те добавили ссылочку на общие зависимости и все вместе ушли в свой первый спринт, полный
    приключений, на две недели.
  </p>

  <p data-item="text">
    И вот она, победа. Мы компания, которая использует микро-фронтенды. У нас все хорошо. Но что же наш герой увидел,
    после двух недель?
  </p>

  <p data-item="text">
    Реакт команды сразу начали собирать обвес для своих приложений, выяснилось что у них общего намного больше. Поэтому
    первую неделю они провели в митингах, потому что финализировали список зависимостей, которые могут переиспользовать.
    Кроме того, они никак не могли сойтись, что им использовать санки или саги, потому что зачем использовать разное?
    Можно же взять одно, заодно можно переиспользовать. В это время вью команда занималась только тем, что постоянно
    делала redeploy новых требований от реакт команд, и пыталась втиснуться в этот список переиспользумых зависимостей,
    ведь как, это же правильно. Но ни строчки полезного кода не написала. Под конец спринта вообще выяснилось, что
    вторая команда хочет писать на хуках&nbsp;&ndash;&nbsp;ведь что? Правильно, микро-фронтенды, пишу на чем хочу. Но
    вью команда не
    была так рада. Это означало, что надо теперь обратно выносить реакт и реакт-дом, поскольку первая команда написала
    много легаси и не может быстро перейти на новую версию, поэтому теперь на страницу грузится несколько версий реакта.
  </p>

  <p data-item="text">
    Когда начался второй спринт, никто уже не писал код. Все были заняты обсуждением. Как только вторая реакт команда
    обновила реакт, за ним потянулись другие пакеты, которые не подходили первой команде. Компания наняла еще одну
    команду, у которых фронтенд на ангуляре. Те сразу сообразили, что нужно переиспользовать примитивы, и написали свой
    ui-kit. АПИ, конечно, никто не стал обсуждать, итак очень много митингов. Поэтому как есть. А чтобы другие команды
    тоже могли переиспользовать кнопочки, ангулярщики написали ui-kit на stencil, чтобы поддерживать веб-компоненты и
    переиспользовать меж фреймворков, но то, что реакт не может в веб-компоненты стало понятно после. Вью команда вообще
    теперь не понимает, зачем ей, чтобы приложение работало, нужно загрузить 4 разных рантайма, 3 разных тулзы для
    мониторинга ошибок и lodash с underscore. А это еще никто не занимался бэкендом!
  </p>

  <p data-item="text">
    Оказавшись посреди этого ада, наш герой пал в отчаяние. Все, что писали в священных скрижалях, оказалось ложью.
    Никогда “Работает в теории” не будет работать на практике. Ни о какой скорости и ни о каком фокусе речь не идет,
    когда
    буквально нужно 20 человек из разных команд, чтобы решить, что в _ будет лежать lodash, а не какой-нибудь сервис
    переводов. И, если вы думаете, что я гиперболизирую, то это нет так, за исключением некоторых деталей, это
    практически реальная история.
  </p>

  <p data-item="text">
    Но что же делать? Когда нет выхода, давайте вернемся ко входу. Что мы усвоили? Веб-приложение&nbsp;&ndash;&nbsp;это
    верстка, которая
    содержит ссылки на стили и ссылки на скрипты, которые помогают оживить это приложение. Скрипты эти, должны быть
    написаны на языке javascript, потому что другой язык браузер не понимает. Мы знаем, что микро-фронтенды допускают,
    что каждая часть может быть написана на чем угодно, главное чтобы не блочила поток обновлений и доставки изменений в
    прод, а еще мы знаем, что все фреймворки разные, хоть и придерживаются общих моделей&nbsp;&ndash;&nbsp;отсюда
    следует, что
    изначальное понимание микро-фронтендов&nbsp;&ndash;&nbsp;это создание монстра франкенштейна. Как бы да, ноги от
    разных людей, и ухо
    немного пахнет, но он же ходит и все довольны? Так-то да, но это мертвое тело, причем несколько мертвых тел, время
    такому телу не друг.
  </p>

  <p data-item="text">
    Чтобы микро-фронтенды заработали как они задумывались, необходимо все подвести под общий знаменатель. А он уже
    известен, это javascript. Нам нужно что-то, что сделает остальную работу. Это семейство компилируемых фреймворков.
    И, на мой взгляд, самый яркий представитель&nbsp;&ndash;&nbsp;свелт.
  </p>

  <p data-item="text">
    В чем идея?
  </p>

  <p data-item="text">
    Компилируемые фрэймворки всегда на выходе имеют простой javascript. Только самое необходимое для того, чтобы
    приложение завелось. Но при этом они сохраняют всю прелесть декларативных фрэймворков высокого уровня. Когда мы
    пишем
    на транспилируемых фрэймворках (реакт, ангуляр), мы в итоге тоже получаем javascript, но при этом мы еще получаем
    толстый слой с абстракциями, который позволяет этому javascript работать. Поэтому давайте попробуем переизобрести
    микро-фронтенды.
  </p>

  <p data-item="text">
    <a href="https://vtcaregorodtcev.github.io/blog/reactive_microfrontends/act_3">Продолжить чтение</a>
  </p>
</div>
