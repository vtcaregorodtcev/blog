<link href="./style.css" rel="stylesheet">
</link>

<div data-item="container">

  <img class="intro-img" src="./assets/onechance.png" />

  <br />

  <h1> Акт III. Сколько успешных вариантов у нас?</h1>

  <p data-item="text">
    Как так получилось, что в попытках обуздать сложность мы порождаем ещё большую сложность. Вопрос, конечно, очень
    сложный. Возможно, такова природа человека и по-другому быть не может. Человек всегда был заложником того, что он
    изобретал для облегчений своих страданий. Простой пример&nbsp;&ndash;&nbsp;наш телефон, который теперь больше наш
    хозяин чем мы его.
    Но вопрос не “кто виноват?”, вопрос&nbsp;&ndash;&nbsp;“что делать?”
  </p>

  <p data-item="text">
    «Вадим, вот ты говоришь, фреймворки сложные, и работают только по одиночке, как тогда получать удовольствие от
    работы если я не смогу пользоваться ими при создании микро-фронтендов?».
  </p>

  <p data-item="text">
    Давайте разбираться вместе.
  </p>

  <ul>
    <li>1. Во-первых, микро-фронтенды&nbsp;&ndash;&nbsp;это не серебряная пуля, и глупо пытаться вставить их в любую
      компанию.</li>
    <li>2. Во-вторых, вы должны выбирать технологию для проекта, а не проект для технологии, если вы конечно не учитесь
      в этот
      момент.</li>
    <li>3. В-третьих, если у вас микро-фронтенды, то вы уже all set.</li>
  </ul>

  <p data-item="text">
    Вам нужен только js. Сейчас объясню. Я недавно посмотрел доклад одного разработчика с react berlin, случайно увидел
    в <a target="_blank" href="https://bit.ly/2ZRqBF6">рекомендациях на youtube</a>. И знаете, очень крутая мысль у
    него, если ты не знаешь как что-то работает, из-за сложных абстракций или синтаксиса, но знаешь результат и как это
    использовать, попробуй переизобрести это. Разработчик который писал этот инструмент также имел в распоряжении только
    js. Поэтому давайте изобретем микро-фронтенды вместе с нуля. Конечно же, сейчас я говорю больше с технической
    стороны, о том как можно организовать сборку микро-фронтендов в одно приложение и чтобы оно не развалилось. Но
    аспектов, связанных с организацией команд и вообще пересмотра привычных процессов мы тоже коснемся.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Давайте начнем. Чтобы я хотел видеть в микро-фронтендах с точки зрения разработчика и технической реализации?
  </p>

  <ul>
    <li>1. Иметь возможность объединять несколько приложений в одно при этом сохраняя консистентность общей системы.
    </li>
    <li>2. Иметь возможность коммуникации между этими приложениями.</li>
    <li>3. Иметь возможность тестировать эти приложения, а также их коммуникацию.</li>
    <li>4. Иметь возможность независимого деплоя приложений.</li>
  </ul>

  <span class="divider">.................</span>

  <p data-item="text">
    Начнем с первого пункта. Все примеры будут для придуманного приложения-каталога, мы смотрим галерею, выбираем
    некоторый магазин, можем перейти в этот магазин и накидать товаров в корзину. Таким образом, мы хотим, чтобы у нас
    было три микро-фронтенда. Собственно для общей галереи магазинов, для отдельного магазина и для корзины с товарами.
  </p>

  <p data-item="text">
    Что из того что мы уже знаем, что нам сейчас понадобиться? Две вещи. Наши микро-фронтенды, в конечном итоге, это два
    скрипта js и css. Второй момент, мы должны сказать нашему хост приложению где взять эти скрипты и куда их положить,
    чтобы магия произошла. Поэтому, нам необходимо завести некоторый <span data-item="highlight">manifest.json</span>,
    который будет содержать информацию о каждом отдельном микро-фронтенде. Я предполагаю, что минимальное описание
    должно выглядеть так.
  </p>

  <img src="./assets/manifest.png" />

  <br />

  <p data-item="text">
    Нам достаточно имени, таргета в хост приложении, где мы собираемся монтировать микро-фронтенд, и пару урлов, откуда
    мы собираемся стянуть скрипты.
  </p>

  <p data-item="text">
    Далее мы можем настроить нечто следующее:
  </p>

  <img src="./assets/gallerymf.png" />

  <br />

  <p data-item="text">
    Мы можем описать наши микро-фронтенды для нескольких сред, поскольку когда мы будем дебажить наше хост приложение,
    или просто прогонять тесты на CI нам могут быть не нужны скрипты с продакшена.
  </p>

  <p data-item="text">
    После этого, мы можем создать мапу для всех микро-фронтендов и положить ее где-нибудь на конфиг-сервере. Далее к ней
    будут иметь доступ все команды, которые могут независимо настраивать свои отдельные микро-фронтенды.
  </p>

  <img src="./assets/mapmf.png" />

  <br />

  <p data-item="text">
    Теперь, когда мы знаем всю информацию о местоположении микро-фронтенда, что нам нужно чтобы он заработал на
    странице?
  </p>

  <p data-item="text">
    Во-первых, мы должны убедиться, что сам микро-фронтенд осознает себя.
  </p>

  <img src="./assets/targetfor.png" />

  <br />

  <p data-item="text">
    Мы говорим, проверь текущий environment и возьми таргет для нашего микро-фронтенда. Потом мы его находим и передаем
    в приложение. Заметьте, мы также оставили fallback для body, когда заявленного таргета нет на странице, так-как нам
    помимо общей интеграции нужно разрабатывать микро-фронтенд независимо от остальных. И, если мы не находим таргет -
    это значит, что сейчас мы в локальном режиме.
  </p>

  <p data-item="text">
    Во-вторых, нам нужно убедиться, что в хост приложении есть место, в которое собирается встроиться микро-фронтенд.
  </p>

  <img src="./assets/loadforhost.png" />

  <br />

  <p data-item="text">
    Теперь когда обе стороны знают друг о друге, давайте посмотрим, что делает функция load.
  </p>

  <img src="./assets/funcload.png" />

  <br />

  <p data-item="text">
    Вот и все, единственное, что еще может понадобиться&nbsp;&ndash;&nbsp;это проверить, что не добавили ли мы раньше
    наши скрипты и
    просто удалить их перед добавлением новых.
  </p>

  <p data-item="text">
    Какие бенефиты мы можем получить используя такой подход? Я вижу три:
  </p>

  <ul>
    <li>
      1. Мы можем грузить наши скрипты и стили на какой-нибудь cdn. И, если нам потребуется часто загружать их обратно,
      скрипты легко закешировать.</li>
    <li> 2. Если расположить все скрипты на одном домене, не нужно будет решать проблему аутентификации/авторизации для
      разных
      микро-фронтендов. Достаточно оставить всю логику, относящуюся к авторизации, в хост приложении и остальные
      микро-фронтенды уже будут синхронизированы. Возможно, потребуется какой-нибудь хак, когда мы будем локально писать
      микро-фронтенд, совсем изолированно ото всех, но здесь мы всегда можем замокать наш сервер.</li>
    <li> 3. Мы можем пушить наши скрипты хоть по 10 раз в день в этот наш cdn, при этом никого мы трогать не будем, мы
      знаем
      где встраивается наше приложение, мы знаем какие скрипты ожидает хост.</li>
  </ul>

  <span class="divider">.................</span>

  <p data-item="text">
    Перейдем к следующему вопросу. Как нам настроить коммуникации среди микро-фронтендов? Какие опции мы знаем?
  </p>

  <ul>
    <li>события</li>
    <li>бродкаст ченэл</li>
  </ul>

  <p data-item="text">
    Но у этих двух подходов есть проблемы. События уж очень требуют внимания. Они асинхронные и могут быть раскиданы
    по
    самым неожиданным местам. Это делает их крайне сложными в тестировании.
  </p>

  <p data-item="text">
    Что с бродкастом? Когда я говорил, что если у нас есть только js, то мы уже all set, я лукавил. Сейчас очень
    трудно
    представить разработку на js без какого-нибудь типизирующего инструмента. Собственно свелт поэтому и обзавелся
    поддержкой ts. И, поскольку бродкаст ченел&nbsp;&ndash;&nbsp;это все-таки нативная реализация, вы столкнетесь с
    некоторыми
    трудностями
    при типизации ваших данных, поскольку чтобы вы не передали в postMessage, это станет <span
      data-item="highlight">any</span>. Поэтому я решил написать свой велосипед.
  </p>

  <p data-item="text">
    В чем идея? Оставить подход как у бродкаст ченел с общей шиной сообщений, но типизировать события, которые могут
    передаваться по этой шине. То есть, если мы знаем, что микро-фронтенд Галерея должен общаться с хост приложением,
    то
    мы сами создаем все необходимые события для этого взаимодействия.
  </p>

  <img src="./assets/busevent.png" />

  <span class="divider">.................</span>

  <img src="./assets/galleryitemonlick.png" />

  <span class="divider">.................</span>

  <img src="./assets/hostapp.png" />

  <br />

  <p data-item="text">
    Далее нам нужно посмотреть как выглядит сама шина сообщений.
  </p>

  <img src="./assets/exporthandler.png" />

  <br />

  <p data-item="text">
    И ее реализация:
  </p>

  <img src="./assets/busconstructor.png" />

  <br />

  <p data-item="text">
    То есть самая базовая реализация pub/sub паттерна. А для того чтобы сделать процесс подключения к этой шине более
    лаконичным, заведем также несколько хелперов.
  </p>

  <img src="./assets/helpers.png" />

  <br />

  <p data-item="text">
    Какие бенефиты я вижу в этом подходе:
  </p>

  <ul>
    <li>1. Все наши сообщения типизированы;</li>
    <li>2. Декларативный способ работы с шиной сообщений;</li>
    <li>3. Удобство в тестировании. Как правило, все общие ресурсы должны быть известны на старте разработки, в том
      числе
      названия всех событий и направления взаимодействия. Поэтому как только начинается локальная разработка, человеку,
      который занимается дебагом, не составляет труда просто из консоли браузера подключаться к шине событий и сгенерить
      нужное событие с нужными данными.</li>
  </ul>

  <p data-item="text">
    В общем-то, в остальном тестирование микро-фронтендов ничем не отличается от обычных приложений. Но есть один
    момент
    относительно интеграционного тестирования и тестов. Они не нужны. Но, наверно, вы уже догадались сами почему. Это
    межкомандные взаимодействия, что, мы уже знаем, не работает с микро-фронтендами. А также, даже если кто-то сам
    напишет эти тесты, кто их будет поддерживать в актуальном состоянии&nbsp;&ndash;&nbsp;большая загадка. Лучше
    использовать что-то
    вроде <span data-item="highlight">Consumer-Driven-Contracts</span>, когда каждый микро-фронтенд описывается как
    перечень того, что ему необходимо для корректной работы, а не в виде тестов в реальной среде. Это тема для
    отдельного доклада, а с выдержкой <a target="_blank"
      href="https://martinfowler.com/articles/consumerDrivenContracts.html">можно познакомится на martinfowler</a>.
  </p>

  <span class="divider">.................</span>

  <p data-item="text">
    Следующий вопрос, который мы рассмотрим&nbsp;&ndash;&nbsp;<span data-item="highlight">независимый деплой</span>. На
    самом деле, это, пожалуй, самый легкий вопрос, поскольку существует огромное кол-во площадок, где можно просто
    положить свои скрипты.
    Тот же гитхаб и github pages, или heroku. Я выбрал firebase, у них даже есть такая опция&nbsp;&ndash;&nbsp;хостинг с
    небольшой
    аналитикой из коробки. Все, что нам нужно, установить firebase tools, вызвать в терминале <span
      data-item="highlight">firebase init</span> и проследовать инструкциям.
  </p>

  <p data-item="text">
    И это все. Несколько незамысловатых действий и мы получаем наш фреймворк для микро-фронтендов. Осталось только
    убедить своего пиэма, что вам нужно все поменять в вашей компании. Потому что надо быть первыми, ну надо! <a
      target="_blank" href="https://github.com/vtcaregorodtcev/svelte-reactive-micro-frontends">Оставлю ссылочку</a>
    на
    исходники и работающие микро-фронтенды.
  </p>

  <br />

  <h1>Заключение</h1>

  <p data-item="text">
    Итак, о чем это я тут рассказвал в трех частях
  </p>

  <ul>
    <li>1. Если вы используете Фреймворк Х и вас все устраивает&nbsp;&ndash;&nbsp;это замечательно.</li>
    <li>2. Микро-фронтенды позволяют решить некоторые организационные моменты в вашей работе. Вы можете фокусироваться
      на
      проблеме пользователя не отвлекаясь на коммуникации между разными командами.</li>
    <li>3. Микро-фронтенды позволяют вам писать инкапсулированный код, который можно независимо от других деплоить в
      продакшен.</li>
    <li>4. Инкапсуляция и независимость позволяет вам постоянно улучшать вашу кодовую базу.</li>
    <li>5. Если вы хотите использовать ваш Фреймворк Х вместе с микро-фронтендами, скорее всего у вас не получится, ну
      или
      получатся свои микро-фронтенды в вакууме.</li>
    <li>6. Фреймворки сложные и не подходят для отдельных микро-фронтендов, возможно, только для хост приложений.</li>
    <li>7. Ниша микро-фронтендов остается за компилируемыми фреймворками.</li>
  </ul>

  <p data-item="text">
    Можно использовать несложные фреймворки&nbsp;&ndash;&nbsp;например преакт. Но у него нет своего пути развития. Это
    роль
    преследования, что делает такие фреймворки как свелт более приоритетными. Модульная сущность микро-фронтендов,
    реактивность взаимодействия делает свелт практически идеальным кандидатом. Микро-фронтенды&nbsp;&ndash;&nbsp;это про
    компилируемые
    фреймворки и про свелт в частности.
  </p>

  <br />

  <h1>Эпилог</h1>

  <p data-item="text">
    Что же, наш герой вынес замечательный урок. В погоне за прекрасным, подобно кружке Канемана, велик соблазн
    переоценивать то, что мы имеем и преуменьшать цену того что нам пытаются продать, но как сам Канеман и говорил -
    “Думай медленно”, позволь новой мысли просочиться сквозь тебя, и ты увидишь результат.
  </p>

  <p data-item="text">
    P.S. Если возникли вопросы к материалу или заметили ошибку, welcome to PR's. Или напишите мне в твиттер <a
      target="_blank" href="https://twitter.com/v_hadoocken">v_hadoocken</a>
  </p>

</div>
