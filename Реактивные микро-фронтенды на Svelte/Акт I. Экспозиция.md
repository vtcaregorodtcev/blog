<style>
  p[data-item="text"] {
    text-indent: 2em;
    text-align: justify;
  }

  div[data-item="container"] {
    display: flex;
    flex-direction: column;
    max-width: 1024px;
    justify-content: center;
  }

  span[data-item="caption"] {
    font-size: 11px;
    opacity: 0.8;
    text-align: right;
    width: 100%;
    position: relative;
    top: -12px;
  }

  p[data-item="list"] {
    text-align: left;
  }

  span[data-item="highlight"] {
    color: #ffe5b4;
  }
</style>

<div data-item="container">
  <p align="center">
    <img title="" src="./assets/intro.png" alt="" width="160" data-align="center">
  </p>

  <p data-item="text">
    Всем привет. Меня зовут Вадим. Я работаю lead разработчиком в компании EPAM. Мне нравится иногда делать доклады с использованием Svelte и размышлять на темы из области what if …?. Собственно, то, что вы сейчас читаете - это результат объединения двух моих увлечений.
  </p>

  <p data-item="text">
    Почему стоит потратить время на прочтение?
    Конечно, в первую очередь - это то, что тема на слуху, стоит только бросить взгляд на гугл-трендс чтобы увидеть растущую популярность. А если посмотреть программу ближайшего HolyJs, то можно также несколько раз заметить знакомое слово.
  </p>
  <br/>

  ![trends](./assets/trends.png)

  <span data-item="caption">
    «Microfrontend» trends
    <a terget="_blank" href='https://trends.google.ru/trends/explore?date=today%205-y&q=microfrontend'>https://trends.google.ru/trends/explore?date=today%205-y&q=microfrontend
    </a>
  </span>

  <br/>

  1. Следующий аргумент, нет ничего лучшего чем смотреть как кто-то набивает шишки. Эту информацию можно использовать в своей работе.
  2. `Svelte` теперь официально поддерживает `typescript` - мне кажется, самое больное место, которое тормозило использование фреймворка.
  3. `Реактивность`, `Микро-фронтенды`, “фреймворк только для виджетов”, на интуитивном уровне это все близко-близко друг к другу.
  4. В рунете достаточно материала по микро-фронтендам, но большинство, из которых я встречал либо описывают негативный опыт, либо описывают видение, которое отлично от моего. В этом докладе я бы хотел задать другое направление, через которое мы по-другому посмотрим на микро-фронтенды. Здесь нужно сделать оговорку, что `Svelte` как базовый инструмент выбран не совсем случайно, но он может быть заменен другим. Впрочем, обо все этом подробнее я расскажу дальше.
  5. И последнее, кроме всего прочего, я дитя поколения `миллениалов` и получаю такое же удовольствие от просмотра фильмов, как и от чтения художественной литературы. Поэтому сегодня предлагаю вам окунуться в мою историю. Я, конечно, не Нолан, но постарался следовать классическим канонам трехактной структуры. Поехали.

  <br/>

  # Акт I. Экспозиция
  <p data-item="text">
    Как водится, в любой классической истории необходимо присутствие протагониста. Таким протагонистом в этом докладе буду я сам. Но чтобы не ломать четвертую стену я буду называть себя “героем этого доклада” или просто “наш герой”.
  </p>

  <p data-item="text">
    Так вот, наш герой и его работа ничем не отличается от обычной рутины программиста. Просыпается к дэйли, работает и отдыхает за компьютером, сидит до поздней ночи. Но как я уже сказал, однажды этот привычный лад заканчивается и зерно сомнения дает всходы. Наш герой узнает, что за холмами, люди помимо реакта, используют другие фреймворки, а иногда и вовсе не нуждаются в них. Но самое удивительное, что  редакс - это не единственный менеджер состояния. Наш герой загуглил mobx и оказывается он справляется со своей задачей на том же уровне, а иногда и лучше! Но вот, что странно - по всей документации красной нитью плетется слово <span data-item="highlight">реактивность.</span>
  </p>

  <br/>

  ## Реактивность.
  <p data-item="text">
    Наверно, самый простой способ объяснить, что такое реактивность не используя термины из программирования - это сравнить ее с эффектом бабочки. Взмах крыла бабочки в Европе приводит к торнадо в Америке. Между двумя этими событиями может быть сколь угодно промежуточных событий, но они есть и мы знаем, что торнадо - это следствие взмаха крыла. Это как натянутое полотно пожарников, и все кто его держит точно почувствуют когда на него упадет человек. Но вернёмся  к жизненным примерам.
  </p>

  <p data-item="text">
    Самый частый пример, который можно увидеть в любой статье про реактивность - это работа в excel.
  </p>

  <p data-item="text">
    Допустим у нас есть выражение типа <span data-item="highlight">A = B + C</span>. Если у нас императивный подход, то в <span data-item="highlight">А</span> попадет результат сложения  <span data-item="highlight">В и С</span>, использующих значения на момент выполнения этой операции. Переменные <span data-item="highlight">В и С</span> могут быть сто раз перезаписаны с новыми значениями, но это никак не повлияет на значение <span data-item="highlight">А</span>.
  </p>

  <br/>

  ![trends](./assets/imperative.png)

  <span data-item="caption">
    Императивный подход
  </span>

  <br/>

  <p data-item="text">
    А теперь представим, что мы пишем код в <span data-item="highlight">excel</span>. И у нас есть выражение типа <span data-item="highlight">А1 = B1 + C1</span>. Два столбца и сумма двух ячеек в ячейке третьего. Теперь же, в любой из моментов, когда мы будем менять значения ячеек <span data-item="highlight">В1</span> или <span data-item="highlight">С1</span>, значение ячейки <span data-item="highlight">А1</span> будет изменятся тоже. Этот процесс получил название - распространение изменений. А механизм, через который удается реализовать данный процесс, называют стримом, или потоком данных. Собственно отсюда и вытекают две главных составляющих реактивного программирования - <span data-item="highlight">реактивные ячейки и потоки данных</span>.
  </p>

  <br/>

  ![trends](./assets/excel.png)

  <span data-item="caption">
    Реактивный подход
  </span>

  <br/>

  ## Принципы реактивности

  <p data-item="text">
    Далее, если мы обратимся к принципам реактивного программирования, описанным в книге <span data-item="highlight"><a target="_blank" href="https://livebook.manning.com/book/functional-reactive-programming/chapter-1/1">“Реактивное программирование в действии”</a></span>, мы увидим:
  </p>

  1. Реактивность - это реакция на изменение данных;
  2. Система, написанная в реактивном стиле, является событийно-ориентированной (event-based);
  3. Программа, написанная в реактивном стиле должна рассматриваться как поток данных (flow of data), а не как классический поток управления (flow of control)

  <p data-item="text">
    Все это позволяет нам ослабить связь между компонентами нашей программы/системы/приложения и писать модульный код. Это в прямом смысле означает, что классический подход к написанию кода больше не работает, нам более не важен порядок в каком будут написаны и вызваны наши инструкции. На первый взгляд выглядит как нелепица, но дайте мне объяснить все на примере.
  </p>

  <p data-item="text">
    Допустим нам нужно приготовить омлет, у нас есть рецепт и список покупок. Если бы мы следовали императивному подходу, то нам следовало бы хорошенько продумать последовательность наших действий, сходить в пятерочку за углом, купить молоко, купить яйца, включить плиту, выставить температуру, разбить яйца в миску, перемешать, добавить молоко и так далее. Все будет прекрасно работать, но если у нас появяться новые условия или новые действия, например, мы хотим пригласить гостей, и знаем что, у кого-то непереносимость лактозы. То нам необходимо будет проделать некоторую дополнительную работу (добавить или удалить шаги), чтобы исходная инструкция осталась рабочей.
  </p>

  <p data-item="text">
    Мы не справимся с задачей, весело провести завтрак, если мы будем использовать обычное молоко, а сами приглашаем гостей, которым необходимо безлактозное. Получается такая зависимость от инструкций, которые еще не случились.
  </p>

  <br/>

  ![trends](./assets/imperative-eggs.png)

  <span data-item="caption">
     Готовим омлет по императивному
  </span>

  <br/>

  <p data-item="text">
    Но если мы развернем зависимость в обратную сторону, то мы сможем ослабить связь между инструкциями и переиспользовать их как независимые модули.
  </p>

  <p data-item="text">
    Что я имею в виду. Вместо того чтобы покупать молоко для специальных гостей, мы приглашаем гостей, основываясь на купленном молоке. Таким образом наш исходный алгоритм не разбивается на более мелкие шаги, а наоборот собирается из таких мелких модулей.
  </p>

  <p data-item="text">
    Еще проще. У нас есть два независимых модуля, которые выполняют функцию приглашения гостей. Один зовет гостей с переносимостью лактозы, другой без, возможно там что-то еще, не суть сейчас. Оба они подписаны на событие о том какое молоко куплено. И как только такое событие происходит, срабатывает соответствующий модуль. Эти модули ничего не знают про общую цель, они лишь выполняют свою функцию в рамках событий, на которые подписаны.
  </p>

  <br/>

  ![trends](./assets/reactive-eggs.png)

  <span data-item="caption">
     Готовим омлет по реактивному
  </span>

  <br/>

  ## Бенефиты реактивности

  <p data-item="text">
    Какие бенефиты это несет:
  </p>

  1. Во-первых, как уже много раз было сказано - модульность и независимость друг от друга, что повышает переиспользуемость данных модулей.
  2. Декларативность, мы больше не говорим “как” сделать, мы говорим “что”. Упаковываем инструкции в модуль и называем привычным нам языком.

  <br/>

  <p data-item="text">
    Предвкушаю ваш следующий вопрос...
  </p>

  <br/>

  ![trends](./assets/thefuck.png)

  <br/>

  <p data-item="text">
    Поэтому пришло время срывать маски. Все это время под маской реактивного программирования был обычный <span data-item="highlight">observer pattern</span>. Даже если вы не поверили мне и пойдете сами изобретать реактивное программирование на javascript, вы скорее всего изобретаете observer pattern.
  </p>

  <p data-item="text">
    Даже если это будет не классический observer pattern, это все равно будет некоторым подобием событийно-ориентированной архитектуры, о чем мы поговорим чуть далее.
  </p>

  <br/>

  ![trends](./assets/maskoff.png)

  ---

  <p data-item="text">
    Здесь следует провести черту и рассказать в чем между ними отличия, хотя оба термина (событийно-ориентированная архитектура и observer pattern) все еще находятся в поле реактивного программирования и оба удовлетворяют принципу распространения изменения.
  </p>

  <p data-item="text">
    <span data-item="highlight">Event-driven architecture</span> - такой шаблон организации независимых модулей, при котором механизму, который генерирует события в общем-то все равно, кто эти события будет слушать. Это как <span data-item="highlight">broadcast</span>, событие попадает в какой-то общий канал и все его участники это событие могут обработать, асинхронно. Зачастую такие события практически обезличены и не несут какой-либо специфичной информации, возможно только метаданные самого события.
  </p>

  <p data-item="text">
    Отличным примером такого подхода могут служить <span data-item="highlight">DOM события</span>. По большому счету браузеру все равно, какой фреймворк сейчас обрабатывает события, а тем более кто там подписался на клик на бади.
  </p>

  <br/>

  ![trends](./assets/events.png)

  <br/>

  <p data-item="text">
    Второй подход заключается в использовании observer pattern. Ключевое отличие от EDA состоит в том, что элемент, который генерирует событие, заставляет всех своих подписчиков обработать это событие в синхронном режиме.
  </p>

  <p data-item="text">
    Жонглируя этими подходами, расширяя и сужая возможности, можно реализовать действительно хороший инструмент распространения изменений в вашем javascript приложении. Я оставлю несколько ссылок на статьи где описываются хорошие реактивные системы в существующих инструментах и фреймворках, таких как <a target="_blank" href="https://blog.logrocket.com/truly-reactive-programming-with-svelte-3-0-321b49b75969/#:~:text=Svelte%203.0%20moves%20reactivity%20out,API%20and%20into%20the%20language.&text=setState%20in%20React%20%28and%20most,completely%20unaware%20of%20data%20changes.">Svelte</a>, <a target="_blank" href="https://antfu.me/posts/watch-with-reactivity/">Vue</a>, <a target="_blank" href="https://www.pzuraq.com/what-makes-a-good-reactive-system/">Ember, RxJs, Elm</a>.
  </p>

  ---

  <p data-item="text">
    Итак, разобрались. Реактивность - неплохой взгляд на то, как можно писать код. Но нет ли у вас ощущения, что все равно, что-то не так?
  </p>

  <p data-item="text">
    Потому что, если все хорошо, мы бы взяли наш отлаженный рабочий реактивный фреймворк и работали бы в свое удовольствие. Но нет, мы каждое утро заходим в твиттер и видим как кто-то постит, что нашел сильно пахнущий кусок кода в своем проекте. Читаем новые книжки про архитектуру. Собираемся на конференциях и пытаемся научится чему-то. Зачем, если есть такая вещь как реактивность? Зачем нам что-то другое?
  </p>

  <p data-item="text">
    Что же, в каждой статье на медиуме присутствует раздел про минусы, такой раздел есть и у реактивности. Это управление сложностью. Как только ваш проект разрастается, зачастую, если разработчики пропустили этот момент, вся реактивщина превращается в тыкву. Поскольку реактивные системы - это, по большей части, модульные системы, связность таких модулей становится очень тесной. Весь проект начинает выглядеть как таиландские провода. Становится непонятно, откуда и куда идут сообщения, что триггерит что. Продолжать разработку, тестирование и прочие активности становится ужасно больно.
  </p>

  <br/>

  ![trends](./assets/wires.png)

  <br/>

  <p data-item="text">
    Дойдя до этого этапа, наш герой, казалось, разочаровался в жизни. Зачем давать такую сладкую надежду, чтобы тут же облить ее керосином и поджечь, мир не может быть настолько жестоким. Но первый акт подходит к концу, поэтому на горизонте маячит переломный момент. Наш герой находит “рояль в кустах”. Книга! Заповеди программирования (не является настоящей книгой)! Наш герой судорожно листает страницы и повторяет, - “ответы, мне нужны ответы!”, глаза останавливаются на строчке, герой читает - “Пишите код так, как будто сопровождать его будет склонный к насилию психопат, который … ”, - “Это все не то!”, - кричит герой. И дойдя до последней страницы, наш герой замечает, как кто-то карандашом, еле-еле видно, нарисовал на обложке несколько символов. Он приглядывается и видит странную надпись.
  </p>

  <p data-item="text">
    💩💩💩&nbsp;лучше чем &nbsp;<span style="font-size:35px">💩</span>
  </p>

  <p data-item="text">
    На лице у него сияет улыбка и он отправляется в свое новое путешествие, из которого он уже не сможет вернуться прежним.
  </p>

</div>
