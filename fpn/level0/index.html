<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="Description" content="Машинное обучение, Эволюционный алгоритм обучения нейронных сетей">
  <title>Фронтендер пишет нейронки. Уровень сложности "Хочу на ручки"</title>
  <link href="./prism.css" rel="stylesheet" />
  <script src="./prism.js"></script>

  <link href="./style.css" rel="stylesheet" />
</head>

<body>
  <img alt="main" class="intro-img" src="./assets/main.png" />

  <div data-item="container">
    <h1>Рано или поздно это должно произойти</h1>

    <p data-item="text">
      Рано или поздно, фронтенд-разработчик устает играть со своими фреймворками, устает докучать коллегам-бэкендерам,
      устает играть в девопс и начинает смотреть в сторону машинного обучения, дата-саенс и вот это вот все. Благо,
      каждый второй курс для тех кто хочет войти вайти способствует этому, крича на всех платформах, как это легко. Я
      тоже насытившись, перекладыванием данных из базы в апи, а потом из апи в таблицы и формы, решил взять небольшой
      отпуск и попробовать применить свои скилы фронтендера в машинном обучении. Благо, существуют такие люди как
      <i>Daniel
        Shiffman</i> и <i>Charlie Gerard</i>, которые своим примером помогают не бросить начатое, увидев первые страницы
      с
      математическими формулами.
    </p>

    <p data-item="text">
      Если мы вернемся немного назад и взглянем на название, то увидим, что я не буду <strike>копировать из
        книжек</strike> бросаться
      наукоемкими словечками, пытаясь объяснить что я сделал.
    </p>

    <p data-item="text">
      Почти уверен, что каждый, услышав словосочетание “машинное обучение” представляет себе картинку, где много-много
      нейронов, в несколько слоев и все переплетены между собой. Так вот, это не случайно. Именно для этого машинное
      обучение и было задумано - имплементировать человеческий мозг и его нейронные сети в цифре.
    </p>

    <br />

    <img alt="neural net" src="./assets/nn.png" />

    <span data-item="caption">
      Схема нейронной сети
    </span>

    <br />

    <p data-item="text">
      В чем идея? Представьте себя зимой, идущим по улице. Вчера было очень тепло и все улицы покрылись слоем грязного
      мокрого снега, со всех крыш капало, а сегодня с утра крепкий мороз. Вы идете вдоль дома и вам что-то подсказывает,
      что не стоит прижиматься уж очень близко к домам, там сосульки, которые опасны для вас. Но к дороге тоже не стоит
      близко подходить, там машины и вообще скользко, можно упасть.
    </p>

    <p data-item="text">
      И в таком режиме вы пытаетесь выбрать оптимальную траекторию своего движения. Так вот, то, что вам подсказывает -
      это ваша нейронная сеть, настоящая. Учитывая большое или не очень, кол-во фактов (измерений), ваша нейронная сеть
      дает вам ответ, куда следует сделать следующий шаг.
    </p>

    <p data-item="text">
      Возьмем это представление и перенесем на картинку выше, и что получается? Первый столбик, как вы уже поняли - это
      все факты, которые имеют для нас значение (погода вчера и сегодня, состояние дорог, сосульки и тд).
    </p>

    <p data-item="details">
      Их в реальной жизни, может быть в сотни раз больше (я не утрирую), поскольку настоящая нейронная сеть может
      принимать во внимание около 200-300 объектов (число Данбара), но сознание не способно держать в себе более 7
      объектов (попробуйте запомнить 10-15 рандомных чисел), поэтому некоторые факты мы не осознаем. Но в чем прелесть
      искусственных нейронных сетей, мы сами выбираем кол-во фактов, которые для нас будут играть значение, тем самым мы
      понимаем, что искусственные сети, при определенных условиях будут намного производительней.
    </p>
    <br />

    <p data-item="text">
      Последний столбик - это один из возможных вариантов, куда нам следует сделать шаг, а все что посередине - магия.
      Нейронная сеть как черный ящик.
    </p>

    <p data-item="text">
      Говоря черный ящик - выдаю в себе любовь к тестам. Именно так. Сейчас нам не особо важно какие именно внутренние
      алгоритмы использует та или иная сеть. Мы просто бросаем некоторые рандомные факты в нее и получаем ответ, как нам
      поступить.
    </p>

    <p data-item="text">
      “Но мир немножко сложнее” - скажете вы, допустим если у меня на обуви хороший протектор, то зачем мне следить за
      скользкостью дороги, хожу где могу.
    </p>

    <p data-item="text">
      Да, это так. Поэтому если вы посмотрите на картинку нейронной сети еще раз, то увидите, что каждый нейрон имеет
      связь с каждым другим, это неспроста. Эти связи называют весами, или если сказать по другому, коэффициенты, с
      которыми мы должны воспринимать тот или иной факт.
    </p>

    <br />

    <img alt="neural net weights" src="./assets/nn2.png" />

    <span data-item="caption">
      Веса нейронной сети
    </span>

    <br />

    <p data-item="text">
      Допустим, как мы уже сказали, нам не страшен лед если мы в ботинках. Тогда важность этого факта будет минимальной,
      мы можем учитывать только <i><span data-item="highlight">0.1*X<sub>1</sub></span> (W<sub>1</sub> == 0.1)</i> от
      любого
      значения
      <i>X<sub>1</sub></i>.
      (Да, забыл
      сказать, так как у нас
      искусственная нейронная
      сеть, каждый факт должен быть выражен каким либо числом, но лучше, конечно, нормированным от -1 до 1). В этом
      случае какое бы значение мы не получили, мы будем принижать его важность в 10 раз. И наоборот, Важность падения
      сосулек для нашей жизни максимальная поэтому вес для такой связи будет <i><span
          data-item="highlight">1*X<sub>2</sub></span> (W<sub>2</sub> == 1)</i>.
    </p>

    <p data-item="text">
      Существует отдельное поднаправление в машинном обучении, которое занимается подбором весов для различных ситуаций.
      Впрочем, этого мы еще немного коснемся.
    </p>

    <p data-item="text">
      Теперь, когда мы, немного ближе рассмотрели нашу картинку, напоминает ли она еще что-то? По мне, так это самая
      настоящая функция (или более правильное название - функция активации). <i><span
          data-item="highlight">f(Х)&nbsp;=&nbsp;У</span></i>. Где <i>Х</i> - это матрица всех входных данных
      или input слой, <i>У</i> - это матрица всевозможных вариантов исхода или output слой, и некоторый алгоритм
      <i>f</i>, который по
      какому-то паттерну преобразовывает входной слой в выходной.
    </p>

    <p data-item="text">
      Этот самый алгоритм может состоять еще из тысячи промежуточных слоев, которые в свою очередь также будут выглядеть
      как функции. И этот процесс преобразования будет перерабатывать наш <i>input</i> слой <i>X</i> через все эти
      функции пока
      тот не
      станет нашим <i>output</i> слоем <i>У</i>. Но поскольку мы условились - что это черный ящик, давайте считать, что
      это некий
      алгоритм, который видит некоторый паттерн в наших входных данных и показывает нам некоторый выходной вариант,
      который больше всего подходит для этого паттерна.
    </p>

    <p data-item="text">
      Собственно, как и настоящая нейронная сеть, искусственная никогда не может быть на сто процентов уверена в
      выходном варианте, поэтому выходной слой обычно представлен в виде <span data-item="highlight">матрицы
        вероятностей</span>, что какой-либо из <i>У<sub>i</sub></i>
      будет ответом на паттерн входящих данных.
    </p>

    <p data-item="text">
      И уже мы сами можем дать определенный <i><span data-item="highlight">label</span></i> этим вероятностям. Допустим
      если
      нейронка говорит, что наиболее
      вероятный маневр - это <i>У<sub>3</sub></i>, а мы ранее дали этому выходному варианту <i>label</i> = <span
        data-item="highlight">“поверни
        налево”</span>, то в этой ситуации мы
      говорим, нейронная сеть предложила повернуть налево. Хотя нейронка еще предлагала два других варианта, но
      поскольку их вероятность была меньше, мы ими пренебрегли.
    </p>

    <p data-item="text">
      Тут вы можете еще раз возразить. “Жизнь все еще намного сложнее!” И снова вы правы. Как же тогда люди учаться
      делать что-то, находить паттерны, если их веса никто не исправляет, никто не регулирует?
    </p>

    <p data-item="text">
      Тут мы подошли к такому понятию, как обучение нейронной сети. Собственно как мы можем научить нейронную сеть
      настраивать свои веса?
    </p>

    <p data-item="text">
      Пока мы далеко не ушли очень рекомендую к просмотру видео с канала <i>thecodingtrain</i>, где Дэниель Шифман
      рассказывает
      и великолепно показывает на живых примерах, как работают нейронные сети. Как они обучаются, как они обрабатывают
      ошибки и так далее.
    </p>

    <p data-item="text">
      Собственно существует две больших группы методов обучения нейронной сети. Обучение с учителем и обучение без
      учителя.
    </p>

    <p data-item="text">
      Пример с погодой, который мы рассмотрели выше, относится к группе методов обучения с подкреплением (без учителя).
      Данная группа считается наиболее естественной и близкой к настоящим нейронным сетям.
    </p>

    <p data-item="text">
      Что это значит? Это значит, что веса никто не настраивает. Нейронная сеть, делает какие-то действия, и сама
      понимает какие паттерны, что значат. Но для закрепления знания, нейронной сети нужны стимулы. Для настоящей
      нейронной сети таким стимулом является жизнь ее носителя. Если после очередного шага, носитель остается жить, то
      вероятнее всего это был правильный шаг и сеть его запомнит, поправит веса и в будущем сделает снова.
    </p>

    <p data-item="text">
      Для искусственных сетей такой стимул приходится придумывать самому человеку, и выражается он также в некотором
      числовом эквиваленте. Чем больше <i>score</i> тем удачнее был шаг.
    </p>

    <p data-item="text">
      В противовес предыдущим группам, идет группа методов обучения с учителем. В данном случае, после каждого ответа
      нейронной сети, нечто (учитель), говорит, правильно ли это или нет, и говорит как велика ошибка, чтобы нейронка
      смогла правильно перенастроить свои веса. В этом случае, проблемная область должна быть более менее
      детерминированной, например как распознавание образов.
    </p>

    <p data-item="text">
      Итак, собрав эту небольшую информацию, как и зачем работают нейронки, давайте немного отдохнем и поиграем
      <strike>в raid
        shadow legends</strike>. Играть мы будем в <i>dino game</i> от создателей <i>google chrome</i>. Но нажимать
      пробел
      было бы очень просто, давайте напишем
      игру с нуля
      и нейронную сеть, которая сама будет играть в эту игру?
    </p>

    <h2>Dino game</h2>

    <p data-item="text">
      В написании игры нам будет помогать такой редактор как <i>p5.js</i>. Данный инструмент уже заточен на реализацию
      подобных
      задач, когда необходимо реализовывать игровой цикл, работу с канвасом и обработкой событий во время самой игры.
      Любой скетч на р5 имеет две функции <i>setup</i>, где мы инициализируем все наши переменные, рисуем канвас
      определенного
      размера и прочие вещи, и <i>draw</i>, собственно функция, которая вызывается на каждой итерации игрового цикла,
      здесь мы
      можем обновлять наши анимации и прочее.
    </p>

    <p data-item="text">
      В чем идея? Мы создаем канвас, помещаем на него изображения дино и кактусов, и на каждой итерации игры мы
      перерисовываем их, создавая иллюзию движения. Попутно мы проверяем коллизии дино и кактусов, и если она есть, то
      игра заканчивается.
    </p>

    <p data-item="text">
      При работе с подобными играми, очень удобно следовать объектно-ориентированной модели, когда вся логика работы с
      отдельными объектами спрятана внутри класса, а все остальные манипуляции уже происходят непосредственно над
      экземплярами этого класса. Поэтому для наших целей нам нужны два класса. Один для дино и один для кактуса.
    </p>

    <pre>
        <code class="language-js">
class Cactus {
  constructor() {}
}

class Dino {
  constructor() {}
}
      </code>
    </pre>

    <p data-item="text">
      Здесь есть небольшая загвоздка, поскольку манипуляции с отрисовкой дино и кактусов на канвасе - это все-таки не
      элементы самих этих классов (канвас - внешняя среда, по отношению к дино и кактусу), то и не стоит тащить эту
      логику во внутрь. Но как тогда быть? Первое решение, которое пришло в голову, это унаследовать и дино и кактус от
      общего интерфейса, что-то вроде <i>GameObject</i>, который имеет один метод <i>onTick</i>, который будет
      вызываться каждую
      итерацию игрового цикла, в этом случае мы можем вернуть все необходимые данные для отрисовки объекта, при этом не
      раскрывая внутренней кухни, как мы эти данные подготовили. Но для простоты, просто будем возвращать сам объект.
    </p>

    <pre>
      <code class="language-js">
...

onTick(cb = () => { }) {
  cb(this);
}

...
    </code>
  </pre>

    <p data-item="text">
      Следующая хитрость, к которой мы прибегнем, это иллюзия движения и прыжков дино. На самом деле, дино будет
      находиться на одной и той же координате <i>Х</i>, а все сгенерированные кактусы будут менять свое положение и за
      счет
      этого будет казаться, что дино бежит мимо кактусов.
    </p>

    <p data-item="text">
      Далее мы вводим такие понятия как состояние дино (бег, прыжок, падение). У дино будет максимальная высота, на
      которую он сможет прыгнуть и скорость прыжка. После этого, при каждой итерации игрового цикла мы проверяем
      состояние дино: если дино бежит - мы пропускаем итерацию, если находиться в прыжке, то инкрементируем текущую
      высоту, если приземляется, то декрементируем, проверяя при этом, максимальную высоту и уровень земли. Таким
      образом мы только изменяем координату <i>У</i>, имитируя таким образом прыжок.
    </p>

    <pre>
      <code class="language-js">
switch (this.state) {
  case DinoStateEnum.run: break;
  case DinoStateEnum.jump: {
    this.currH += this.jumpSpeed;

    if (this.currH == this.maxH) {
      this.state = DinoStateEnum.fall;
    }

    break;
  }
  case DinoStateEnum.fall: {
    this.currH -= this.jumpSpeed;

    if (this.currH == 0) {
      this.state = DinoStateEnum.run;
    }

    break;
  }
}
    </code>
  </pre>

    <p data-item="text">
      Теперь мы с определенной вероятностью генерируем кактусы и отрисовываем их на канвасе. На каждой итерации мы
      смещаем их в сторону дино, создавая иллюзию бега. Вот и вся игра. Давайте уже перейдем в нейронкам.
    </p>

    <pre>
      <code class="language-js">
function updateCactuses() {
  const copy = cactuses.slice();

  for (let i = 0; i < copy.length; i++) {
    let c = copy[i];

    c.onTick(cactus => {
      drawCactus(cactus)

      cactus.currDistance -= dinoVelocitySlider.value();

      if (cactus.currDistance + cactusW < initialDinoW && !cactus.passDinoPosition) {
        updateDinoScore()

        cactus.passDinoPosition = true;
      }

      if (cactus.currDistance < 0) {
        cactuses.splice(i, 1);
      }
    })
  }
}
    </code>
  </pre>

    <p data-item="text">
      Понимаю, что это прямо очень сжатое описание, того что сделано, поэтому оставляю <a
        href="https://github.com/vtcaregorodtcev/dino-ml/blob/master/sketch.js" target="_blank"
        rel="noopener noreferrer">ссылочку на исходники</a>.
    </p>

    <h2>Нейроэволюция</h2>

    <p data-item="text">
      В этом проекте мы будем использовать <i>tensorflowjs</i> и первое, что нам нужно сделать - это подключить скрипт с
      официального сайта. Далее, чтобы оптимизировать работу в браузере нам нужно установить бэкенд для вычислений.
      Теперь мы готовы писать нейронки.
    </p>

    <pre>
      <code class="language-js">
&lt;script
  src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js">
&lt;/script>

&lt;script>
  tf.setBackend('cpu') // tf глобальная переменная
&lt;/script>
    </code>
  </pre>

    <p data-item="text">
      Итак, что такое нейронная сеть с точки зрения нашей игры? Это непосредственно мозг самого дино. Дино должен уметь
      оценить окружающую обстановку, и принять решение, прыгать или не прыгать. Но теперь встает вопрос, как нам научить
      дино принимать решения?
    </p>

    <p data-item="text">
      Мы можем использовать один из методов обучения с учителем, например. Поиграть в эту игру самостоятельно, записать
      каждое наше решение при различных ситуациях и положениях кактуса, потом скормить эти данные дино и запустить игру
      в автономном режиме, теперь дино будет сам принимать решения на основе наших, когда-то принятых. Но это выглядит
      достаточно сложно, не для нашего уровня сложности. Нужно поддерживать несколько режимов игры, нужно реализовать
      механизм сбора данных, сохранить и загрузить данные, научиться техникам выбора правильных весов и тд и тп.
      Наверно, этот способ не совсем подходит для нашего текущего уровня.
    </p>

    <p data-item="text">
      Тогда нам остается обучение с подкреплением. Мы никаким образом не будем влиять на дино, и он сам будет принимать
      решения. И стимулом для него будет наибольшая продолжительность жизни, пока тот не напорется на кактус. Но сейчас
      все еще остается вопрос, как дино будет учиться и какие веса мы должны ему поставить?
    </p>

    <p data-item="text">
      Самый легкий алгоритм, который мы можем представить - это брутфорс. Мы просто рандомно выбираем веса и надеемся,
      что они будут примерно правильно настроены, чтобы адекватно реагировать на внешние условия. (Я сейчас говорю
      только про веса, потому что условия, которые мы будем учитывать, рассмотрим чуть позже).
    </p>

    <p data-item="text">
      Таким образом мы можем получить идеально выученного дино как сразу же, так и через пару лет генерирования
      рандомных дино. Как нам ускорить этот процесс? Нам потребуется эволюция.
    </p>

    <p data-item="text">
      В чем идея? Мы генерируем популяцию рандомно - настроенных дино размером 200-300 особей, и смотрим насколько они
      способны выживать. Далее мы выбираем несколько особей, у которых продолжительность жизни (best score) наибольшая,
      пытаемся немного их мутировать, как если бы это делала настоящая эволюция и создаем новое поколение. То есть
      имитируем настоящую эволюцию, поощряя продолжительность жизни. В итоге через несколько поколений, преобладающим
      качеством наших дино, должна стать долгая жизнь. Это как выводить пшеницу с наибольшими зернами (селекция).
    </p>

    <p data-item="text">
      Теперь когда с теорией, наконец, закончили, давайте перейдем к имплементации.
    </p>

    <p data-item="text">
      Мы будем реализовывать простую <span data-item="highlight">нейронную сеть из трех слоев</span>.
    </p>

    <ul>
      <li>1. Входной слой - это наши значимые условия окружающей среды,</li>
      <li>2. Cкрытый слой - наш черный ящик,</li>
      <li>3. Выходной слой - решения, которые принимает дино.</li>
    </ul>

    <p data-item="text">
      В качестве <span data-item="highlight">значимых условий</span>, я предлагаю рассматривать:
    </p>

    <ul>
      <li>1. Tекущее положение дино по оси <i>У</i>,</li>
      <li>2. Скорость дино,</li>
      <li>3. Расстояние до ближайшего кактуса,</li>
      <li>4. Условие, когда дино приближается сразу к нескольким кактусам подряд.</li>
    </ul>

    <p data-item="text">
      Всего 4 входных узла или нейрона.
    </p>

    <p data-item="text">
      Настройку скрытого слоя доверим великому рандому и просто выберем 8 нейронов. Выходных нейронов будет 2, два
      решения, <span data-item="highlight">прыгать или не прыгать</span>.
    </p>

    <p data-item="text">
      Чтобы создать модель нейронной сети нам нужно сделать следующее:
    </p>

    <pre>
      <code class="language-js">
createModel() {
  const model = tf.sequential();

  const hiddenLayer = tf.layers.dense({
    units: this.hidden_nodes, // кол-во нейронов в скрытом слое (8)
    inputShape: [this.input_nodes], // кол-во нейронов во входном слое (4)
    activation: "sigmoid" // функция активации
  });

  model.add(hiddenLayer);

  const outputLayer = tf.layers.dense({
    units: this.output_nodes, // кол-во нейронов в выходном слое (2)
    activation: "sigmoid"
  });

  model.add(outputLayer);

  return model;
}
    </code>
  </pre>

    <p data-item="text">
      После создания пустой модели при помощи <i>sequential()</i> мы настраиваем наши слои. Мы создаем скрытый слой,
      говорим сколько нейронов в нем будет и сколько нейронов
      было в слое перед этим. Также нам необходимо выбрать функцию активации. Правило, по которому будут активироваться
      нейроны текущего слоя. Эта тема тоже довольно сложная и поэтому пока оставим это. Возьмем самую популярную
      функцию, которая называется <i>sigmoid</i>.
    </p>

    <p data-item="text">
      Добавим слой в модель и создадим таким же образом выходной слой, при этом заметьте, теперь нам нет необходимости
      указывать кол-во нейронов в прошлом слое, так как <i>tensorflow</i> сделает это за нас.
    </p>

    <p data-item="text">
      Модель готова, теперь нам нужно научить ее думать и принимать решения.
    </p>

    <pre>
      <code class="language-js">
predict(inputs) {
  return tf.tidy(() => {
    const xs = tf.tensor([inputs]); // создание тензора из массива

    const ys = this.model.predict(xs); // предсказание сети

    const output = ys.dataSync(); // превращение тензора в массив

    return output;
  });
}
    </code>
  </pre>

    <p data-item="text">
      Поскольку <i>tensorflow</i> по своей природе иммутабельный, то на кажой операцию создается новый <i>tensor</i>
      (массив определенной размерности) и чтобы после нескольких операций у нас не текла память, участки кода, в которых
      мы
      обрабатываем тензоры принято оборачивать в специальный колбэк <i>tidy</i>.
    </p>

    <p data-item="text">
      Как уже сказано, <i>tensorflow</i> работает только с тензорами, поэтому в нашу функцию предсказания мы посылаем
      тензор,
      полученный путем преобразования одномерного массива. После обработки входящих данных, мы также получаем тензор и
      чтобы превратить его в удобочитаемый формат, вызываем специальный метод. (Можем читать эти данные, как синхронно
      так и асинхронно). На выходе мы также получим одномерный массив длиной 2, поскольку мы указали 2 выходных нейрона.
      И если мы вспомним начало, то поймем, что массив заполнен вероятностями, того или иного решения. То есть прыгать
      или нет. Нам теперь достаточно проверить, что <i>output[0] > output[1]</i> чтобы дино прыгнул.
    </p>

    <p data-item="text">
      Вот так в несколько строчек можно реализовать простую нейронную сеть для <i>dino npc</i>.
    </p>

    <p data-item="text">
      Следующий шаг - реализовать генетический алгоритм, создание популяции, отбор лучших и мутация.
    </p>

    <p data-item="text">
      Сначала мы устанавливаем размер популяции, потом генерируем это кол-во дино и в цикле отрисовываем каждого.
    </p>

    <pre>
      <code class="language-js">
function drawDino(dino) {
  if (dino.isDead) return;

  if (dino.state != DinoStateEnum.run) {
    // если дино прыгает, то рисуем его на текущей высоте
    image(dino2, initialDinoW, initialDinoH - dino.currH, dinoW, dinoH); // р5 специальный метод добавления изображения на канвас
  } else if (iteration % 7 == 0)
    // иначе имитируем бег и перебирание ножками
    image(dino1, initialDinoW, initialDinoH, dinoW, dinoH);
  else
    image(dino2, initialDinoW, initialDinoH, dinoW, dinoH);
}
    </code>
  </pre>

    <p data-item="text">
      Потом нам нужно определить условие окончания поколения. В нашем случае это не представляет труда, мы просто на
      каждой итерации проверяем, что существует ли хотя бы один из дино, который не пересекался с кактусом, если нет, то
      мы создаем новое поколение. А вот тут остановимся и рассмотрим этот момент подробней.
    </p>

    <pre>
      <code class="language-js">
function updateGenerationIfNeeded() {
  if (dinos.every(d => d.isDead)) {
    cactuses = [];
    dinoVelocitySlider.value(initDinoVelocity);

    dinos = newGeneration(dinos)
  }
}
    </code>
  </pre>

    <p data-item="text">
      Чтобы создать новое поколение, нам нужно сначала выбрать лучших, чтобы в следующем поколении доминировали те веса,
      которые ведут к большему времени жизни. Но эти веса не должны быть абсолютно такими же, поскольку тогда не
      происходит никакой эволюции и нейронка не обучается. Поэтому мы вводим такое понятие как мутация.
    </p>

    <p data-item="text">
      Также, чтобы не
      потерять накопленный успех, мы вводим понятие вероятности мутации. Чтобы
      не было так, что после каждого поколения мы имеем абсолютно разные особи.
    </p>

    <p data-item="text">
      Функция мутации может выглядеть так. Мы в лоб пробегаем все веса и с некой вероятностью изменяем значения.
    </p>

    <pre>
      <code class="language-js">
mutate(rate) {
  tf.tidy(() => {
    const weights = this.model.getWeights(); // берем веса модели

    const mutatedWeights = [];

    for (let i = 0; i < weights.length; i++) {
      let tensor = weights[i]; // каждый вес - это тензор
      let shape = weights[i].shape;
      let values = tensor.dataSync().slice();

      for (let j = 0; j < values.length; j++) {
        if (Math.random() < rate) { // мутируем если нам повезло
          let w = values[j];
          values[j] = w + this.gaussianRandom(); // рандомное нормальное изменение в интервале от -1 до 1
        }
      }

      let newTensor = tf.tensor(values, shape);
      mutatedWeights[i] = newTensor;
    }

    this.model.setWeights(mutatedWeights); // ставим мутировавшие веса
  });
}
    </code>
  </pre>

    <p data-item="text">
      Теперь вернемся к тому, как мы все таки отбираем особи. Для начала нам необходимо нормализовать все результаты от
      каждого дино. Для этого мы все суммируем и потом делим индивидуальный результат на общую сумму. Этим действием мы
      получили значение <i>fitness</i>.
    </p>

    <pre>
      <code class="language-js">
const calculateFitness = (dinos) => {
  let sum = 0;

  dinos.map(d => sum += d.score)
  dinos.map(d => d.fitness = d.score / sum)
}
    </code>
  </pre>

    <p data-item="text">
      Теперь нам нужно отсортировать дино по убыванию. После сортировки мы можем начинать генерировать новое поколение.
      Берем рандомного дино из начала отсортированной популяции (лучшие находятся в начале), потом мы копируем его мозг,
      мутируем и создаем нового дино.
    </p>

    <p data-item="text">
      Функция для такого действия может выглядеть так.
    </p>

    <pre>
      <code class="language-js">
const pickOne = (dinos) => { // на входе дино отсортированные по убыванию fitness
  let index = 0;
  let r = Math.random();

  while (r > 0) {
    r = r - dinos[index].fitness;
    index++;
  }

  index--;

  let dino = dinos[index] // берем дино где-то из начала списка, как повезет с rate

  const dinoBrain = dino.brain.copy();
  dinoBrain.mutate(0.2) // делаем мутировавшую копию

  let newDino = new Dino(dinoBrain) // дино для нового поколения

  return newDino;
}
    </code>
  </pre>

    <p data-item="details">
      Но почему именно так? Почему бы просто не взять самого лучшего дино каждый раз? Потому что в этом случае, каждое
      новое поколение будет становится все менее разнообразнее и в итоге выродится, так и не научившись прыгать через
      кактус.
    </p>
    <br />

    <p data-item="text">
      И это все. Теперь у нас есть новое поколение, которое немного отличается от лучших особей прошлого поколения. И
      теперь с каждый новым поколением, особи становятся более натренированные, чтобы перепрыгивать через кактусы и не
      задевать их.
    </p>

    <pre>
      <code class="language-js">
for (let i = 0; i < TOTAL; i++) {
  newDinos.push(pickOne(oldDinos));
}

console.log(currentGeneration++);
return newDinos;
    </code>
  </pre>

    <p data-item="text">
      Запустив симуляцию мы можем увидеть несколько стратегий, которые появляются в первом поколении, дино либо прыгает
      постоянно, либо прыгает далеко перед кактусом и приземляется сразу за ним, либо прыгает прямо перед кактусом. К
      десятому поколению эти стратегии усредняются и дино способен прожить 50+ кактусов.
    </p>

    <video autoplay muted loop>
      <source src="./assets/game.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <p data-item="text">
      <a href="https://github.com/vtcaregorodtcev/dino-ml" target="_blank"
        rel="noopener noreferrer">Исходники проекта на гитхабе</a>.
    </p>

    <p data-item="text">
      P.S. Если возникли вопросы к материалу или заметили ошибку, welcome to PR's. Или напишите мне в твиттер <a
        rel="noopener" rel="noreferrer" target="_blank" href="https://twitter.com/v_hadoocken">v_hadoocken</a>
    </p>

</body>

</html>
